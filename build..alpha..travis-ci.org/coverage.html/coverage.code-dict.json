{"/home/travis/build/npmtest/node-npmtest-pg-promise/test.js":"/* istanbul instrument in package npmtest_pg_promise */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-pg-promise/lib.npmtest_pg_promise.js":"/* istanbul instrument in package npmtest_pg_promise */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_pg_promise = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_pg_promise = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-pg-promise/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-pg-promise && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_pg_promise */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_pg_promise\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_pg_promise.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_pg_promise.rollup.js'] =\n            local.assetsDict['/assets.npmtest_pg_promise.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_pg_promise.__dirname + '/lib.npmtest_pg_promise.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-pg-promise/node_modules/pg-promise/lib/index.js":"'use strict';\r\n\r\nvar nodeHighVer = +process.versions.node.split('.')[0];\r\n\r\n// istanbul ignore if\r\nif (nodeHighVer < 4) {\r\n\r\n    // Starting from pg-promise v5.6.0, the library no longer supports legacy\r\n    // Node.js versions 0.10 and 0.12, requiring Node.js 4.x as the minimum.\r\n\r\n    throw new Error('Minimum Node.js version required by pg-promise is 4.x');\r\n}\r\n\r\nmodule.exports = require('./main');\r\n","/home/travis/build/npmtest/node-npmtest-pg-promise/node_modules/pg-promise/lib/main.js":"'use strict';\r\n\r\nvar $npm = {\r\n    con: require('manakin').local,\r\n    path: require('path'),\r\n    pg: require('pg'),\r\n    minify: require('pg-minify'),\r\n    array: require('./array'),\r\n    adapter: require('./adapter'),\r\n    result: require('./result'),\r\n    promise: require('./promise'),\r\n    formatting: require('./formatting'),\r\n    helpers: require('./helpers'),\r\n    queryFile: require('./queryFile'),\r\n    errors: require('./errors'),\r\n    utils: require('./utils'),\r\n    pubUtils: require('./utils/public'),\r\n    mode: require('./txMode'),\r\n    types: require('./types'),\r\n    package: require('../package.json')\r\n};\r\n\r\n/**\r\n * @author Vitaly Tomilov\r\n * @module pg-promise\r\n *\r\n * @description\r\n * ### Initialization Options\r\n *\r\n * Below is the complete list of _Initialization Options_ for the library.\r\n *\r\n * @param {object} [options]\r\n * Library Initialization Options.\r\n *\r\n * @param {boolean} [options.pgFormatting=false]\r\n * Redirects query formatting to PG.\r\n *\r\n * This property can be set dynamically (before or after initialization).\r\n *\r\n * @param {boolean} [options.pgNative=false]\r\n * Use $[Native Bindings]. Library $[pg-native] must be installed, or else it will throw an error.\r\n *\r\n * This is a static property (can only be set prior to initialization).\r\n *\r\n * @param {object|function} [options.promiseLib=Promise]\r\n * Overrides the default promise library.\r\n *\r\n * This is a static property (can only be set prior to initialization).\r\n *\r\n * @param {boolean} [options.noLocking=false]\r\n * Prevents protocol locking.\r\n *\r\n * By default, the library locks its protocol to read-only access, as a fool-proof mechanism.\r\n * Specifically for the {@link event:extend extend} event this serves as a protection against overriding existing\r\n * properties or trying to set them at the wrong time.\r\n *\r\n * If this provision gets in the way of using a mock-up framework for your tests, you can force\r\n * the library to deactivate most of the locks by setting `noLocking` = `true` within the options.\r\n *\r\n * This property can be set dynamically (before or after initialization).\r\n *\r\n * @param {boolean} [options.capSQL=false]\r\n * Capitalizes any SQL generated by the library.\r\n *\r\n * By default, all internal SQL within the library is generated using the low case.\r\n * If, however, you want all SQL to be capitalized instead, set `capSQL` = `true`.\r\n *\r\n * This is purely a cosmetic feature.\r\n *\r\n * This property can be set dynamically (before or after initialization).\r\n *\r\n * @param {boolean} [options.noWarnings=false]\r\n * Disables all diagnostic warnings in the library (which is ill-advised).\r\n *\r\n * This property can be set dynamically (before or after initialization).\r\n *\r\n * @param {function} [options.connect]\r\n * Global event {@link event:connect connect} handler.\r\n *\r\n * This property can be set dynamically (before or after initialization).\r\n *\r\n * @param {function} [options.disconnect]\r\n * Global event {@link event:disconnect disconnect} handler.\r\n *\r\n * This property can be set dynamically (before or after initialization).\r\n *\r\n * @param {function} [options.query]\r\n * Global event {@link event:query query} handler.\r\n *\r\n * This property can be set dynamically (before or after initialization).\r\n *\r\n * @param {function} [options.receive]\r\n * Global event {@link event:receive receive} handler.\r\n *\r\n * @param {function} [options.task]\r\n * Global event {@link event:task task} handler.\r\n *\r\n * This property can be set dynamically (before or after initialization).\r\n *\r\n * @param {function} [options.transact]\r\n * Global event {@link event:transact transact} handler.\r\n *\r\n * This property can be set dynamically (before or after initialization).\r\n *\r\n * @param {function} [options.error]\r\n * Global event {@link event:error error} handler.\r\n *\r\n * This property can be set dynamically (before or after initialization).\r\n *\r\n * @param {function} [options.extend]\r\n * Global event {@link event:extend extend} handler.\r\n *\r\n * This property can be set dynamically (before or after initialization).\r\n *\r\n * @example\r\n *\r\n * var options = {\r\n *   // Initialization Options\r\n * };\r\n *\r\n * var pgp = require('pg-promise')(options);\r\n *\r\n */\r\nfunction $main(options) {\r\n\r\n    if ($npm.utils.isNull(options)) {\r\n        options = {};\r\n    } else {\r\n        if (typeof options !== 'object') {\r\n            throw new TypeError('Invalid initialization options.');\r\n        }\r\n\r\n        // list of supported initialization options:\r\n        var validOptions = ['pgFormatting', 'pgNative', 'promiseLib', 'noLocking', 'capSQL', 'noWarnings',\r\n            'connect', 'disconnect', 'query', 'receive', 'task', 'transact', 'error', 'extend'];\r\n\r\n        if (!options.noWarnings) {\r\n            for (var prop in options) {\r\n                if (validOptions.indexOf(prop) === -1) {\r\n                    $npm.con.warn('WARNING: Invalid property \\'%s\\' in initialization options.\\n%s\\n', prop, $npm.utils.getLocalStack(3));\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    var pg = $npm.pg, p = $npm.promise(options.promiseLib);\r\n\r\n    var config = {\r\n        version: $npm.package.version,\r\n        promiseLib: p.promiseLib,\r\n        promise: p.promise\r\n    };\r\n\r\n    $npm.utils.addReadProp(config, '$npm', {}, true);\r\n\r\n    // Locking properties that cannot be changed later:\r\n    $npm.utils.addReadProp(options, 'promiseLib', options.promiseLib);\r\n    $npm.utils.addReadProp(options, 'pgNative', !!options.pgNative);\r\n\r\n    config.options = options;\r\n\r\n    // istanbul ignore next:\r\n    // we do not cover code specific to Native Bindings\r\n    if (options.pgNative) {\r\n        pg = $npm.pg.native;\r\n        if ($npm.utils.isNull(pg)) {\r\n            throw new Error('Failed to initialize Native Bindings.');\r\n        }\r\n    }\r\n\r\n    var Database = require('./database')(config);\r\n\r\n    var inst = (cn, dc) => {\r\n        if ($npm.utils.isText(cn) || (cn && typeof cn === 'object')) {\r\n            return new Database(cn, dc, config);\r\n        }\r\n        throw new TypeError('Invalid connection details.');\r\n    };\r\n\r\n    $npm.utils.addReadProperties(inst, rootNameSpace);\r\n\r\n    /**\r\n     * @member {external:PG} pg\r\n     * @readonly\r\n     * @description\r\n     * Instance of the $[PG] library that's being used, depending on initialization option `pgNative`:\r\n     *  - regular `pg` module instance, without option `pgNative`, or equal to `false` (default)\r\n     *  - `pg` module instance with $[Native Bindings], if option `pgNative` was set.\r\n     *\r\n     * Available as `pgp.pg`, after initializing the library.\r\n     */\r\n    $npm.utils.addReadProp(inst, 'pg', pg);\r\n\r\n    /**\r\n     * @member {function} end\r\n     * @readonly\r\n     * @description\r\n     * Terminates pg library (call it when exiting the application).\r\n     *\r\n     * Available as `pgp.end`, after initializing the library.\r\n     */\r\n    $npm.utils.addReadProp(inst, 'end', () => {\r\n        pg.end();\r\n    });\r\n\r\n    /**\r\n     * @member {helpers} helpers\r\n     * @readonly\r\n     * @description\r\n     * Namespace for {@link helpers all query-formatting helper functions}.\r\n     *\r\n     * Available as `pgp.helpers`, after initializing the library.\r\n     *\r\n     * @see {@link helpers}.\r\n     */\r\n    $npm.utils.addReadProp(inst, 'helpers', $npm.helpers(config));\r\n\r\n    /**\r\n     * @member {external:spex} spex\r\n     * @readonly\r\n     * @description\r\n     * Initialized instance of the $[spex] module, used by the library within tasks and transactions.\r\n     *\r\n     * Available as `pgp.spex`, after initializing the library.\r\n     *\r\n     * @see\r\n     * {@link Task.batch},\r\n     * {@link Task.page},\r\n     * {@link Task.sequence}\r\n     */\r\n    $npm.utils.addReadProp(inst, 'spex', config.$npm.spex);\r\n\r\n    config.pgp = inst;\r\n    Object.freeze(config);\r\n\r\n    return inst;\r\n}\r\n\r\nvar rootNameSpace = {\r\n\r\n    /**\r\n     * @member {formatting} as\r\n     * @readonly\r\n     * @description\r\n     * Namespace for {@link formatting all query-formatting functions}.\r\n     *\r\n     * Available as `pgp.as`, before and after initializing the library.\r\n     *\r\n     * @see {@link formatting}.\r\n     */\r\n    as: $npm.formatting.as,\r\n\r\n    /**\r\n     * @member {external:pg-minify} minify\r\n     * @readonly\r\n     * @description\r\n     * Instance of the $[pg-minify] library that's used.\r\n     *\r\n     * Available as `pgp.minify`, before and after initializing the library.\r\n     */\r\n    minify: $npm.minify,\r\n\r\n    /**\r\n     * @member {queryResult} queryResult\r\n     * @readonly\r\n     * @description\r\n     * Query Result Mask enumerator.\r\n     *\r\n     * Available as `pgp.queryResult`, before and after initializing the library.\r\n     */\r\n    queryResult: $npm.result,\r\n\r\n    /**\r\n     * @member {PromiseAdapter} PromiseAdapter\r\n     * @readonly\r\n     * @description\r\n     * {@link PromiseAdapter} class.\r\n     *\r\n     * Available as `pgp.PromiseAdapter`, before and after initializing the library.\r\n     */\r\n    PromiseAdapter: $npm.adapter,\r\n\r\n    /**\r\n     * @member {ParameterizedQuery} ParameterizedQuery\r\n     * @readonly\r\n     * @description\r\n     * {@link ParameterizedQuery} class.\r\n     *\r\n     * Available as `pgp.ParameterizedQuery`, before and after initializing the library.\r\n     */\r\n    ParameterizedQuery: $npm.types.ParameterizedQuery,\r\n\r\n    /**\r\n     * @member {PreparedStatement} PreparedStatement\r\n     * @readonly\r\n     * @description\r\n     * {@link PreparedStatement} class.\r\n     *\r\n     * Available as `pgp.PreparedStatement`, before and after initializing the library.\r\n     */\r\n    PreparedStatement: $npm.types.PreparedStatement,\r\n\r\n    /**\r\n     * @member {QueryFile} QueryFile\r\n     * @readonly\r\n     * @description\r\n     * {@link QueryFile} class.\r\n     *\r\n     * Available as `pgp.QueryFile`, before and after initializing the library.\r\n     */\r\n    QueryFile: $npm.queryFile,\r\n\r\n\r\n    /**\r\n     * @member {errors} errors\r\n     * @readonly\r\n     * @description\r\n     * {@link errors} - namespace for all error types.\r\n     *\r\n     * Available as `pgp.errors`, before and after initializing the library.\r\n     */\r\n    errors: $npm.errors,\r\n\r\n    /**\r\n     * @member {utils} utils\r\n     * @readonly\r\n     * @description\r\n     * {@link utils} - namespace for utility functions.\r\n     *\r\n     * Available as `pgp.utils`, before and after initializing the library.\r\n     */\r\n    utils: $npm.pubUtils,\r\n\r\n    /**\r\n     * @member {txMode} txMode\r\n     * @readonly\r\n     * @description\r\n     * {@link txMode Transaction Mode} namespace.\r\n     *\r\n     * Available as `pgp.txMode`, before and after initializing the library.\r\n     */\r\n    txMode: $npm.mode\r\n};\r\n\r\n$npm.utils.addReadProperties($main, rootNameSpace);\r\n\r\nmodule.exports = $main;\r\n\r\n/**\r\n * @external Promise\r\n * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise\r\n */\r\n\r\n/**\r\n * @external PG\r\n * @see https://github.com/brianc/node-postgres/blob/master/lib/index.js#L17\r\n */\r\n\r\n/**\r\n * @external Client\r\n * @see https://github.com/brianc/node-postgres/blob/master/lib/client.js#L20\r\n */\r\n\r\n/**\r\n * @external pg-minify\r\n * @see https://github.com/vitaly-t/pg-minify\r\n */\r\n\r\n/**\r\n * @external spex\r\n * @see https://github.com/vitaly-t/spex\r\n */\r\n","/home/travis/build/npmtest/node-npmtest-pg-promise/node_modules/pg-promise/lib/array.js":"'use strict';\r\n\r\n// Number of times it is faster than the standard 'map', by Node.js versions:\r\n// 0.10.44: ~2.8\r\n// 0.11.16: ~3.8\r\n// 0.12.13: ~3.8\r\n// 4.4.4: ~1.38\r\n// 5.11.0: ~1.44\r\n// 6.1.0: ~8.25\r\nfunction map(arr, cb, obj) {\r\n    var res = new Array(arr.length);\r\n    if (obj) {\r\n        for (var i = 0; i < arr.length; i++) {\r\n            res[i] = cb.call(obj, arr[i], i, arr);\r\n        }\r\n    } else {\r\n        for (var k = 0; k < arr.length; k++) {\r\n            res[k] = cb(arr[k], k, arr);\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\n// Number of times it is faster than the standard 'filter', by Node.js versions:\r\n// 0.10.44: ~2.42\r\n// 0.11.16: ~2.83\r\n// 0.12.13: ~2.78\r\n// 4.4.4: ~1.12\r\n// 5.11.0: ~1.14\r\n// 6.1.0: ~7.54\r\nfunction filter(arr, cb, obj) {\r\n    var res = [];\r\n    if (obj) {\r\n        for (var i = 0; i < arr.length; i++) {\r\n            if (cb.call(obj, arr[i], i, arr)) {\r\n                res.push(arr[i]);\r\n            }\r\n        }\r\n    } else {\r\n        for (var k = 0; k < arr.length; k++) {\r\n            if (cb(arr[k], k, arr)) {\r\n                res.push(arr[k]);\r\n            }\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\n// Number of times it is faster than the standard 'forEach', by Node.js versions:\r\n// 0.10.44: ~3.11\r\n// 0.11.16: ~4.6\r\n// 0.12.13: ~4.4\r\n// 4.4.4: ~1.55\r\n// 5.11.0: ~1.54\r\n// 6.1.0: ~1.21\r\nfunction forEach(arr, cb, obj) {\r\n    if (obj) {\r\n        for (var i = 0; i < arr.length; i++) {\r\n            cb.call(obj, arr[i], i, arr);\r\n        }\r\n    } else {\r\n        for (var k = 0; k < arr.length; k++) {\r\n            cb(arr[k], k, arr);\r\n        }\r\n    }\r\n}\r\n\r\n//////////////////////////\r\n// Custom Methods\r\n//////////////////////////\r\n\r\n// Counts elements based on a condition;\r\nfunction countIf(arr, cb, obj) {\r\n    var count = 0;\r\n    if (obj) {\r\n        for (var i = 0; i < arr.length; i++) {\r\n            count += cb.call(obj, arr[i], i, arr) ? 1 : 0;\r\n        }\r\n    } else {\r\n        for (var k = 0; k < arr.length; k++) {\r\n            count += cb(arr[k], k, arr) ? 1 : 0;\r\n        }\r\n    }\r\n    return count;\r\n}\r\n\r\nmodule.exports = {\r\n    map: map,\r\n    filter: filter,\r\n    forEach: forEach,\r\n    countIf: countIf\r\n};\r\n\r\nObject.freeze(module.exports);\r\n","/home/travis/build/npmtest/node-npmtest-pg-promise/node_modules/pg-promise/lib/adapter.js":"'use strict';\r\n\r\n/**\r\n * @constructor PromiseAdapter\r\n * @summary Adapter for the primary promise operations.\r\n * @description\r\n * Provides compatibility with promise libraries that cannot be recognized automatically,\r\n * via functions that implement the primary operations with promises:\r\n *\r\n *  - construct a new promise with a callback function\r\n *  - resolve a promise with some result data\r\n *  - reject a promise with a reason\r\n *\r\n * The type is available from the library's root: `pgp.PromiseAdapter`.\r\n *\r\n * @param {function} create\r\n * A function that takes a callback parameter and returns a new promise object.\r\n * The callback parameter is expected to be `function(resolve, reject)`.\r\n *\r\n * Passing in anything other than a function will throw `Adapter requires a function to create a promise.`\r\n *\r\n * @param {function} resolve\r\n * A function that takes an optional data parameter and resolves a promise with it.\r\n *\r\n * Passing in anything other than a function will throw `Adapter requires a function to resolve a promise.`\r\n *\r\n * @param {function} reject\r\n * A function that takes an optional error parameter and rejects a promise with it.\r\n *\r\n * Passing in anything other than a function will throw `Adapter requires a function to reject a promise.`\r\n *\r\n * @returns {PromiseAdapter}\r\n */\r\nfunction PromiseAdapter(create, resolve, reject) {\r\n\r\n    if (!(this instanceof PromiseAdapter)) {\r\n        return new PromiseAdapter(create, resolve, reject);\r\n    }\r\n\r\n    this.create = create;\r\n    this.resolve = resolve;\r\n    this.reject = reject;\r\n\r\n    if (typeof create !== 'function') {\r\n        throw new TypeError('Adapter requires a function to create a promise.');\r\n    }\r\n\r\n    if (typeof resolve !== 'function') {\r\n        throw new TypeError('Adapter requires a function to resolve a promise.');\r\n    }\r\n\r\n    if (typeof reject !== 'function') {\r\n        throw new TypeError('Adapter requires a function to reject a promise.');\r\n    }\r\n}\r\n\r\nmodule.exports = PromiseAdapter;\r\n","/home/travis/build/npmtest/node-npmtest-pg-promise/node_modules/pg-promise/lib/result.js":"'use strict';\r\n\r\n/**\r\n * @enum {number}\r\n * @alias queryResult\r\n * @readonly\r\n * @description\r\n * _Query Result Mask._\r\n *\r\n * Binary mask that represents the result expected from queries.\r\n * It is used in the generic {@link Database.query query} method,\r\n * as well as method {@link Database.func func}.\r\n *\r\n * The mask is always the last optional parameter, which defaults to `queryResult.any`.\r\n *\r\n * Any combination of flags is supported, except for `one + many`.\r\n *\r\n * The type is available from the library's root: `pgp.queryResult`.\r\n *\r\n * @see {@link Database.query}, {@link Database.func}\r\n */\r\nvar queryResult = {\r\n    /** Single row is expected. */\r\n    one: 1,\r\n    /** One or more rows expected. */\r\n    many: 2,\r\n    /** Expecting no rows. */\r\n    none: 4,\r\n    /** `many|none` - any result is expected. */\r\n    any: 6\r\n};\r\n\r\nObject.freeze(queryResult);\r\n\r\nmodule.exports = queryResult;\r\n","/home/travis/build/npmtest/node-npmtest-pg-promise/node_modules/pg-promise/lib/promise.js":"'use strict';\r\n\r\nvar PromiseAdapter = require('./adapter');\r\n\r\n//////////////////////////////////////////\r\n// Parses and validates a promise library;\r\nfunction parsePromiseLib(pl) {\r\n\r\n    var promise;\r\n    if (pl instanceof PromiseAdapter) {\r\n        promise = function (func) {\r\n            return pl.create(func);\r\n        };\r\n        promise.resolve = pl.resolve;\r\n        promise.reject = pl.reject;\r\n        return promise;\r\n    }\r\n    var t = typeof pl;\r\n    if (t === 'function' || t === 'object') {\r\n        var Root = typeof pl.Promise === 'function' ? pl.Promise : pl;\r\n        promise = function (func) {\r\n            return new Root(func);\r\n        };\r\n        promise.resolve = Root.resolve;\r\n        promise.reject = Root.reject;\r\n        if (typeof promise.resolve === 'function' && typeof promise.reject === 'function') {\r\n            return promise;\r\n        }\r\n    }\r\n\r\n    throw new TypeError('Invalid promise library specified.');\r\n}\r\n\r\nfunction init(promiseLib) {\r\n    var result = {\r\n        promiseLib: promiseLib\r\n    };\r\n    if (promiseLib) {\r\n        result.promise = parsePromiseLib(promiseLib);\r\n    } else {\r\n        result.promise = parsePromiseLib(Promise);\r\n        result.promiseLib = Promise;\r\n    }\r\n    return result;\r\n}\r\n\r\nmodule.exports = init;\r\n","/home/travis/build/npmtest/node-npmtest-pg-promise/node_modules/pg-promise/lib/formatting.js":"'use strict';\r\n\r\nvar $pgUtils = require('pg/lib/utils');\r\nvar $arr = require('../lib/array');\r\n\r\n// Format Modification Flags;\r\nvar fmFlags = {\r\n    raw: 1, // Raw-Text variable\r\n    name: 2, // SQL Name/Identifier\r\n    json: 4, // JSON modifier\r\n    csv: 8, // CSV modifier\r\n    value: 16 // escaped, but without ''\r\n};\r\n\r\n// Format Modification Map;\r\nvar fmMap = {\r\n    '^': fmFlags.raw,\r\n    ':raw': fmFlags.raw,\r\n    '~': fmFlags.name,\r\n    ':name': fmFlags.name,\r\n    ':json': fmFlags.json,\r\n    ':csv': fmFlags.csv,\r\n    ':value': fmFlags.value,\r\n    '#': fmFlags.value\r\n};\r\n\r\n////////////////////////////////////////////////////\r\n// Converts a single value into its Postgres format.\r\nfunction formatValue(value, fm, obj) {\r\n\r\n    if (typeof value === 'function') {\r\n        return formatValue(resolveFunc(value, obj), fm, obj);\r\n    }\r\n\r\n    if (value && typeof value === 'object') {\r\n        var ctf = value['formatDBType']; // custom type formatting;\r\n        if (typeof ctf === 'function') {\r\n            fm |= value._rawDBType ? fmFlags.raw : 0;\r\n            return formatValue(resolveFunc(ctf, value), fm, obj);\r\n        }\r\n    }\r\n\r\n    var isRaw = !!(fm & fmFlags.raw);\r\n    fm &= ~fmFlags.raw;\r\n\r\n    switch (fm) {\r\n        case fmFlags.name:\r\n            return $as.name(value);\r\n        case fmFlags.json:\r\n            return $as.json(value, isRaw);\r\n        case fmFlags.csv:\r\n            return $as.csv(value);\r\n        case fmFlags.value:\r\n            return $as.value(value);\r\n        default:\r\n            break;\r\n    }\r\n\r\n    if (isNull(value)) {\r\n        throwIfRaw(isRaw);\r\n        return 'null';\r\n    }\r\n\r\n    switch (typeof value) {\r\n        case 'string':\r\n            return $as.text(value, isRaw);\r\n        case 'boolean':\r\n            return $as.bool(value);\r\n        case 'number':\r\n            return $as.number(value);\r\n        default:\r\n            if (value instanceof Date) {\r\n                return $as.date(value, isRaw);\r\n            }\r\n            if (value instanceof Array) {\r\n                return $as.array(value);\r\n            }\r\n            if (value instanceof Buffer) {\r\n                return $as.buffer(value, isRaw);\r\n            }\r\n            return $as.json(value, isRaw);\r\n    }\r\n}\r\n\r\n//////////////////////////////////////////////////////////////////////////\r\n// Converts array of values into PostgreSQL Array Constructor: array[...],\r\n// as per PostgreSQL documentation: http://www.postgresql.org/docs/9.4/static/arrays.html\r\n// Arrays of any depth/dimension are supported.\r\nfunction formatArray(array) {\r\n    var loop = a => '[' + $arr.map(a, v => v instanceof Array ? loop(v) : formatValue(v)).join() + ']';\r\n    return 'array' + loop(array);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////\r\n// Formats array of javascript-type parameters as a csv string,\r\n// so it can be passed into a PostgreSQL function.\r\n// Both single value and array or values are supported.\r\nfunction formatCSV(values) {\r\n    if (values instanceof Array) {\r\n        return $arr.map(values, v => formatValue(v)).join();\r\n    }\r\n    return values === undefined ? '' : formatValue(values);\r\n}\r\n\r\n///////////////////////////////\r\n// Query formatting helpers;\r\nvar formatAs = {\r\n\r\n    object: (query, obj, raw, options) => {\r\n        options = options && typeof options === 'object' ? options : {};\r\n        var pattern = /\\$(?:({)|(\\()|(<)|(\\[)|(\\/))\\s*[a-zA-Z0-9\\$_]+(\\^|~|#|:raw|:name|:json|:csv|:value)?\\s*(?:(?=\\2)(?=\\3)(?=\\4)(?=\\5)}|(?=\\1)(?=\\3)(?=\\4)(?=\\5)\\)|(?=\\1)(?=\\2)(?=\\4)(?=\\5)>|(?=\\1)(?=\\2)(?=\\3)(?=\\5)]|(?=\\1)(?=\\2)(?=\\3)(?=\\4)\\/)/g;\r\n        return query.replace(pattern, name => {\r\n            var v = formatAs.stripName(name.replace(/^\\$[{(<[/]|[\\s})>\\]/]/g, ''), raw);\r\n            if (v.name in obj) {\r\n                return formatValue(obj[v.name], v.fm, obj);\r\n            }\r\n            if (v.name === 'this') {\r\n                return formatValue(obj, v.fm);\r\n            }\r\n            if ('default' in options) {\r\n                var d = options.default, value = typeof d === 'function' ? d.call(obj, v.name, obj) : d;\r\n                return formatValue(value, v.fm, obj);\r\n            }\r\n            if (options.partial) {\r\n                return name;\r\n            }\r\n            // property must exist as the object's own or inherited;\r\n            throw new Error('Property \\'' + v.name + '\\' doesn\\'t exist.');\r\n        });\r\n    },\r\n\r\n    array: (query, array, raw, options) => {\r\n        options = options && typeof options === 'object' ? options : {};\r\n        return query.replace(/\\$([1-9][0-9]{0,3}(?![0-9])(\\^|~|#|:raw|:name|:json|:csv|:value)?)/g, name => {\r\n            var v = formatAs.stripName(name.substr(1), raw);\r\n            var idx = v.name - 1;\r\n            if (idx < array.length) {\r\n                return formatValue(array[idx], v.fm);\r\n            }\r\n            if ('default' in options) {\r\n                var d = options.default, value = typeof d === 'function' ? d.call(array, idx, array) : d;\r\n                return formatValue(value, v.fm);\r\n            }\r\n            if (options.partial) {\r\n                return name;\r\n            }\r\n            throw new RangeError('Variable $' + v.name + ' out of range. Parameters array length: ' + array.length);\r\n        });\r\n    },\r\n\r\n    value: (query, value, raw) => {\r\n        return query.replace(/\\$1(?![0-9])(\\^|~|#|:raw|:name|:json|:csv|:value)?/g, name => {\r\n            var v = formatAs.stripName(name, raw);\r\n            return formatValue(value, v.fm);\r\n        });\r\n    },\r\n\r\n    stripName: (name, raw) => {\r\n        var mod = name.match(/\\^|~|#|:raw|:name|:json|:csv|:value/);\r\n        if (mod) {\r\n            return {\r\n                name: name.substr(0, mod.index),\r\n                fm: fmMap[mod[0]] | (raw ? fmFlags.raw : 0)\r\n            };\r\n        }\r\n        return {\r\n            name: name,\r\n            fm: raw ? fmFlags.raw : null\r\n        };\r\n    }\r\n};\r\n\r\n////////////////////////////////////////////\r\n// Simpler check for null/undefined;\r\nfunction isNull(value) {\r\n    return value === undefined || value === null;\r\n}\r\n\r\n/////////////////////////////////////////\r\n// Wraps a text string in single quotes;\r\nfunction wrapText(text) {\r\n    return '\\'' + text + '\\'';\r\n}\r\n\r\n////////////////////////////////////////////////\r\n// Replaces each single-quote symbol ' with two,\r\n// for compliance with PostgreSQL strings.\r\nfunction safeText(text) {\r\n    return text.replace(/'/g, '\\'\\'');\r\n}\r\n\r\n/////////////////////////////////////////////\r\n// Throws an exception, if flag 'raw' is set.\r\nfunction throwIfRaw(raw) {\r\n    if (raw) {\r\n        throw new TypeError('Values null/undefined cannot be used as raw text.');\r\n    }\r\n}\r\n\r\n////////////////////////////////////////////\r\n// Recursively resolves parameter-function,\r\n// with the optional calling context.\r\nfunction resolveFunc(value, obj) {\r\n    while (typeof value === 'function') {\r\n        value = obj ? value.call(obj) : value();\r\n    }\r\n    return value;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////////\r\n// 'pg-promise' query formatting solution;\r\n//\r\n// It implements two types of formatting, depending on the 'values' passed:\r\n//\r\n// 1. format \"$1, $2, etc\", when 'values' is of type string, boolean, number, date,\r\n//    function or null (or an array of the same types, plus undefined values);\r\n// 2. format $*propName*, when 'values' is an object (not null and not Date),\r\n//    and where * is any of the supported open-close pairs: {}, (), [], <>, //\r\n//\r\n// NOTES:\r\n// 1. Raw-text values can be injected using syntax: $1^,$2^,... or $*propName^*\r\n// 2. If 'values' is an object that supports function formatDBType, either its\r\n//    own or inherited, the actual value and the formatting syntax are determined\r\n//    by the result returned from that function.\r\n//\r\n// When formatting fails, the function throws an error.\r\nfunction $formatQuery(query, values, raw, options) {\r\n    if (typeof query !== 'string') {\r\n        throw new TypeError('Parameter \\'query\\' must be a text string.');\r\n    }\r\n    if (values && typeof values === 'object') {\r\n        var ctf = values['formatDBType']; // custom type formatting;\r\n        if (typeof ctf === 'function') {\r\n            return $formatQuery(query, resolveFunc(ctf, values), raw || values._rawDBType, options);\r\n        }\r\n        if (values instanceof Array) {\r\n            // $1, $2,... formatting to be applied;\r\n            return formatAs.array(query, values, raw, options);\r\n        }\r\n        if (!(values instanceof Date || values instanceof Buffer)) {\r\n            // $*propName* formatting to be applied;\r\n            return formatAs.object(query, values, raw, options);\r\n        }\r\n    }\r\n    // $1 formatting to be applied, if values != undefined;\r\n    return values === undefined ? query : formatAs.value(query, values, raw);\r\n}\r\n\r\n//////////////////////////////////////////////////////\r\n// Formats a standard PostgreSQL function call query;\r\nfunction $formatFunction(funcName, values, capSQL) {\r\n    var sql = capSQL ? 'SELECT * FROM ' : 'select * from ';\r\n    return sql + funcName + '(' + formatCSV(values) + ')';\r\n}\r\n\r\n/**\r\n * @namespace formatting\r\n * @description\r\n * Namespace for all query-formatting functions, available from `pgp.as`, before and after initializing the library.\r\n *\r\n * @property {function} name\r\n * {@link formatting.name name} - formats an SQL name.\r\n *\r\n * @property {function} text\r\n * {@link formatting.text text} - formats a text string.\r\n *\r\n * @property {function} number\r\n * {@link formatting.number number} - formats a number.\r\n *\r\n * @property {function} buffer\r\n * {@link formatting.buffer buffer} - formats a `Buffer` object.\r\n *\r\n * @property {function} value\r\n * {@link formatting.value value} - formats text as an open value.\r\n *\r\n * @property {function} json\r\n * {@link formatting.json json} - formats any value as JSON.\r\n *\r\n * @property {function} func\r\n * {@link formatting.func func} - formats the value returned from a function.\r\n *\r\n * @property {function} format\r\n * {@link formatting.format format} - formats a query according to parameters.\r\n *\r\n */\r\nvar $as = {\r\n\r\n    /**\r\n     * @method formatting.text\r\n     * @description\r\n     * Converts a value into PostgreSQL text presentation, escaped as required.\r\n     *\r\n     * Escaping the result means:\r\n     *  1. Every single-quote (apostrophe) is replaced with two\r\n     *  2. The resulting text is wrapped in apostrophes\r\n     *\r\n     * @param {value|function} value\r\n     * Value to be converted, or a function that returns the value.\r\n     *\r\n     * If the `value` resolves as `null` or `undefined`, while `raw`=`true`,\r\n     * it will throw {@link external:TypeError TypeError} = `Values null/undefined cannot be used as raw text.`\r\n     *\r\n     * @param {boolean} [raw=false]\r\n     * Indicates when not to escape the resulting text.\r\n     *\r\n     * @returns {string}\r\n     *\r\n     * - `null` string, if the `value` resolves as `null` or `undefined`\r\n     * - escaped result of `value.toString()`, if the `value` isn't a string\r\n     * - escaped string version, if `value` is a string.\r\n     *\r\n     *  The result is not escaped, if `raw` was passed in as `true`.\r\n     */\r\n    text: (value, raw) => {\r\n        value = resolveFunc(value);\r\n        if (isNull(value)) {\r\n            throwIfRaw(raw);\r\n            return 'null';\r\n        }\r\n        if (typeof value !== 'string') {\r\n            value = value.toString();\r\n        }\r\n        return raw ? value : wrapText(safeText(value));\r\n    },\r\n\r\n    /**\r\n     * @method formatting.name\r\n     * @description\r\n     * Properly escapes an sql name or identifier, fixing double-quote symbols and wrapping the result in double quotes.\r\n     *\r\n     * Implements a safe way to format SQL Names that neutralizes SQL Injection.\r\n     *\r\n     * @param {string|function|array|object} name\r\n     * SQL name or identifier, or a function that returns it.\r\n     *\r\n     * The name must be at least 1 character long.\r\n     *\r\n     * If `name` doesn't resolve into a non-empty string, it throws {@link external:TypeError TypeError} = `Invalid sql name: ...`\r\n     *\r\n     * If the `name` contains only a single `*` (trailing spaces are ignored), then `name` is returned exactly as is (unescaped).\r\n     *\r\n     * **Added in v.5.2.1:**\r\n     *\r\n     * - If `name` is an Array, it is formatted as a comma-separated list of SQL names\r\n     * - If `name` is a non-Array object, its keys are formatted as a comma-separated list of SQL names\r\n     *\r\n     * Passing in an empty array/object will throw {@link external:Error Error} = `Cannot retrieve sql names from an empty array/object.`\r\n     *\r\n     * @returns {string}\r\n     * The SQL Name/Identifier properly escaped for compliance with the PostgreSQL standard for SQL names and identifiers.\r\n     *\r\n     * @example\r\n     *\r\n     * // example of using v5.2.1 feature:\r\n     * // automatically list object properties as sql names:\r\n     * format('INSERT INTO table(${this~}) VALUES(${one}, ${two})', {\r\n     *     one: 1,\r\n     *     two: 2\r\n     * });\r\n     * //=> INSERT INTO table(\"one\",\"two\") VALUES(1, 2)\r\n     *\r\n     */\r\n    name: name => {\r\n        name = resolveFunc(name);\r\n        if (name) {\r\n            if (typeof name === 'string') {\r\n                return /^\\s*\\*(\\s*)$/.test(name) ? name : formatName(name);\r\n            }\r\n            if (typeof name === 'object') {\r\n                var keys = Array.isArray(name) ? name : Object.keys(name);\r\n                if (!keys.length) {\r\n                    throw new Error('Cannot retrieve sql names from an empty array/object.');\r\n                }\r\n                return $arr.map(keys, value => {\r\n                    if (!value || typeof value !== 'string') {\r\n                        throw new Error('Invalid sql name: ' + JSON.stringify(value));\r\n                    }\r\n                    return formatName(value);\r\n                }).join();\r\n            }\r\n        }\r\n\r\n        throw new TypeError('Invalid sql name: ' + JSON.stringify(name));\r\n\r\n        function formatName(name) {\r\n            return '\"' + name.replace(/\"/g, '\"\"') + '\"';\r\n        }\r\n    },\r\n\r\n    /**\r\n     * @method formatting.value\r\n     * @description\r\n     * Represents an open value, one to be formatted according to its type, properly escaped,\r\n     * but without surrounding quotes for text types.\r\n     *\r\n     * @param {value|function} value\r\n     * Value to be converted, or a function that returns the value.\r\n     *\r\n     * If `value` resolves as `null` or `undefined`, it will throw {@link external:TypeError TypeError} = `Open values cannot be null or undefined.`\r\n     *\r\n     * @returns {string}\r\n     * Formatted and properly escaped string, but without surrounding quotes for text types.\r\n     */\r\n    value: value => {\r\n        value = resolveFunc(value);\r\n        if (isNull(value)) {\r\n            throw new TypeError('Open values cannot be null or undefined.');\r\n        }\r\n        return safeText(formatValue(value, fmFlags.raw));\r\n    },\r\n\r\n    /**\r\n     * @method formatting.buffer\r\n     * @description\r\n     * Converts an object of type `Buffer` into a hex string compatible with PostgreSQL type `bytea`.\r\n     *\r\n     * @param {Buffer|function} obj\r\n     * Object to be converted, or a function that returns one.\r\n     *\r\n     * @param {boolean} [raw=false]\r\n     * Indicates when not to wrap the resulting string in quotes.\r\n     *\r\n     * The generated hex string doesn't need to be escaped.\r\n     *\r\n     * @returns {string}\r\n     */\r\n    buffer: (obj, raw) => {\r\n        obj = resolveFunc(obj);\r\n        if (isNull(obj)) {\r\n            throwIfRaw(raw);\r\n            return 'null';\r\n        }\r\n        if (obj instanceof Buffer) {\r\n            var s = '\\\\x' + obj.toString('hex');\r\n            return raw ? s : wrapText(s);\r\n        }\r\n        throw new TypeError(wrapText(obj) + ' is not a Buffer object.');\r\n    },\r\n\r\n    /**\r\n     * @method formatting.bool\r\n     * @description\r\n     * Converts a truthy value into PostgreSQL boolean presentation.\r\n     *\r\n     * @param {boolean|function} value\r\n     * Value to be converted, or a function that returns the value.\r\n     *\r\n     * @returns {string}\r\n     */\r\n    bool: value => {\r\n        value = resolveFunc(value);\r\n        if (isNull(value)) {\r\n            return 'null';\r\n        }\r\n        return value ? 'true' : 'false';\r\n    },\r\n\r\n    /**\r\n     * @method formatting.date\r\n     * @description\r\n     * Converts a `Date`-type value into PostgreSQL date/time presentation,\r\n     * wrapped in quotes (unless flag `raw` is set).\r\n     *\r\n     * @param {date|function} d\r\n     * Date object to be converted, or a function that returns one.\r\n     *\r\n     * @param {boolean} [raw=false]\r\n     * Indicates when not to escape the value.\r\n     *\r\n     * @returns {string}\r\n     */\r\n    date: (d, raw) => {\r\n        d = resolveFunc(d);\r\n        if (isNull(d)) {\r\n            throwIfRaw(raw);\r\n            return 'null';\r\n        }\r\n        if (d instanceof Date) {\r\n            var s = $pgUtils.prepareValue(d);\r\n            return raw ? s : wrapText(s);\r\n        }\r\n        throw new TypeError(wrapText(d) + ' is not a Date object.');\r\n    },\r\n\r\n    /**\r\n     * @method formatting.number\r\n     * @description\r\n     * Converts a numeric value into its PostgreSQL number presentation,\r\n     * with support for `NaN`, `+Infinity` and `-Infinity`.\r\n     *\r\n     * @param {number|function} num\r\n     * Number to be converted, or a function that returns one.\r\n     *\r\n     * @returns {string}\r\n     */\r\n    number: num => {\r\n        num = resolveFunc(num);\r\n        if (isNull(num)) {\r\n            return 'null';\r\n        }\r\n        if (typeof num !== 'number') {\r\n            throw new TypeError(wrapText(num) + ' is not a number.');\r\n        }\r\n        if (isFinite(num)) {\r\n            return num.toString();\r\n        }\r\n        // Converting NaN/+Infinity/-Infinity according to Postgres documentation:\r\n        // http://www.postgresql.org/docs/9.4/static/datatype-numeric.html#DATATYPE-FLOAT\r\n        //\r\n        // NOTE: strings for 'NaN'/'+Infinity'/'-Infinity' are not case-sensitive.\r\n        if (num === Number.POSITIVE_INFINITY) {\r\n            return wrapText('+Infinity');\r\n        }\r\n        if (num === Number.NEGATIVE_INFINITY) {\r\n            return wrapText('-Infinity');\r\n        }\r\n        return wrapText('NaN');\r\n    },\r\n\r\n    /**\r\n     * @method formatting.array\r\n     * @description\r\n     * Converts an array of values into its PostgreSQL presentation as an Array-Type\r\n     * constructor string: `array[]`.\r\n     *\r\n     * @param {array|function} arr\r\n     * Array to be converted, or a function that returns one.\r\n     *\r\n     * @returns {string}\r\n     */\r\n    array: arr => {\r\n        arr = resolveFunc(arr);\r\n        if (isNull(arr)) {\r\n            return 'null';\r\n        }\r\n        if (arr instanceof Array) {\r\n            return formatArray(arr);\r\n        }\r\n        throw new TypeError(wrapText(arr) + ' is not an Array object.');\r\n    },\r\n\r\n    /**\r\n     * @method formatting.csv\r\n     * @description\r\n     * Converts a single value or an array of values into a CSV string, with all values formatted\r\n     * according to their type.\r\n     *\r\n     * @param {array|value|function} values\r\n     * Value(s) to be converted, or a function that returns it.\r\n     *\r\n     * @returns {string}\r\n     */\r\n    csv: values => formatCSV(resolveFunc(values)),\r\n\r\n    /**\r\n     * @method formatting.json\r\n     * @description\r\n     * Converts any value into JSON (using `JSON.stringify`), and returns it as\r\n     * a valid string, with single-quote symbols fixed, unless flag `raw` is set.\r\n     *\r\n     * @param {object|function} obj\r\n     * Object/Value to be converted, or a function that returns it.\r\n     *\r\n     * @param {boolean} [raw=false]\r\n     * Indicates when not to escape the result.\r\n     *\r\n     * @returns {string}\r\n     */\r\n    json: (obj, raw) => {\r\n        obj = resolveFunc(obj);\r\n        if (isNull(obj)) {\r\n            throwIfRaw(raw);\r\n            return 'null';\r\n        }\r\n        var s = JSON.stringify(obj);\r\n        return raw ? s : wrapText(safeText(s));\r\n    },\r\n\r\n    /**\r\n     * @method formatting.func\r\n     * @description\r\n     * Calls the function to get the actual value, and then formats the result\r\n     * according to its type + `raw` flag.\r\n     *\r\n     * @param {function} func\r\n     * Function to be called, with support for nesting.\r\n     *\r\n     * @param {boolean} [raw=false]\r\n     * Indicates when not to escape the result.\r\n     *\r\n     * @param {object} [obj]\r\n     * `this` context to be passed into the function on all nested levels.\r\n     *\r\n     * @returns {string}\r\n     */\r\n    func: (func, raw, obj) => {\r\n        if (isNull(func)) {\r\n            throwIfRaw(raw);\r\n            return 'null';\r\n        }\r\n        if (typeof func !== 'function') {\r\n            throw new TypeError(wrapText(func) + ' is not a function.');\r\n        }\r\n        var fm = raw ? fmFlags.raw : null;\r\n        if (isNull(obj)) {\r\n            return formatValue(resolveFunc(func), fm);\r\n        }\r\n        if (typeof obj === 'object') {\r\n            return formatValue(resolveFunc(func, obj), fm, obj);\r\n        }\r\n        throw new TypeError(wrapText(obj) + ' is not an object.');\r\n    },\r\n\r\n    /**\r\n     * @method formatting.format\r\n     * @description\r\n     * Replaces variables in a string according to the type of `values`:\r\n     *\r\n     * - Replaces `$1` occurrences when `values` is of type `string`, `boolean`, `number`, `Date`, `Buffer` or when it is `null`.\r\n     * - Replaces variables `$1`, `$2`, ...`$9999` when `values` is an array of parameters. When a variable is out of range,\r\n     *   it throws {@link external:RangeError RangeError} = `Variable $n out of range. Parameters array length: x`, unless\r\n     *   option `partial` is used.\r\n     * - Replaces `$*propName*`, where `*` is any of `{}`, `()`, `[]`, `<>`, `//`, when `values` is an object that's not a\r\n     * `Date`, `Buffer`, {@link QueryFile} or `null`. Special property name `this` refers to the formatting object itself,\r\n     *   to be injected as a JSON string. When referencing a property that doesn't exist in the formatting object, it throws\r\n     *   {@link external:Error Error} = `Property 'PropName' doesn't exist`, unless option `partial` is used.\r\n     *\r\n     * By default, each variable is automatically formatted according to its type, unless it is a special variable:\r\n     * - Raw-text variables end with `:raw` or symbol `^`, and prevent escaping the text. Such variables are not\r\n     *   allowed to be `null` or `undefined`, or the method will throw {@link external:TypeError TypeError} = `Values null/undefined cannot be used as raw text.`\r\n     *   - `$1:raw`, `$2:raw`,..., and `$*propName:raw*` (see `*` above)\r\n     *   - `$1^`, `$2^`,..., and `$*propName^*` (see `*` above)\r\n     * - Open-value variables end with `:value` or symbol `#`, to be escaped, but not wrapped in quotes. Such variables are\r\n     *   not allowed to be `null` or `undefined`, or the method will throw {@link external:TypeError TypeError} = `Open values cannot be null or undefined.`\r\n     *   - `$1:value`, `$2:value`,..., and `$*propName:value*` (see `*` above)\r\n     *   - `$1#`, `$2#`,..., and `$*propName#*` (see `*` above)\r\n     * - SQL name variables end with `:name` or symbol `~` (tilde), and provide proper escaping for SQL names/identifiers:\r\n     *   - `$1:name`, `$2:name`,..., and `$*propName:name*` (see `*` above)\r\n     *   - `$1~`, `$2~`,..., and `$*propName~*` (see `*` above)\r\n     * - JSON override ends with `:json` to format the value of any type as a JSON string\r\n     * - CSV override ends with `:csv` to format an array as a properly escaped comma-separated list of values.\r\n     *\r\n     * @param {string|value|Object} query\r\n     * A query string or a value/object that implements $[Custom Type Formatting], to be formatted according to `values`.\r\n     *\r\n     * **NOTE:** Support for $[Custom Type Formatting] was added in v5.2.7.\r\n     *\r\n     * @param {array|object|value} [values]\r\n     * Formatting parameter(s) / variable value(s).\r\n     *\r\n     * @param {object} [options]\r\n     * Formatting Options.\r\n     *\r\n     * @param {boolean} [options.partial=false]\r\n     * Indicates that we intend to do only a partial replacement, i.e. throw no error when encountering a variable or\r\n     * property name that's missing within the formatting parameters.\r\n     *\r\n     * This option has no meaning when option `default` is present.\r\n     *\r\n     * @param {} [options.default]\r\n     * **Added in v.5.0.5**\r\n     *\r\n     * Sets a default value for every variable that's missing, consequently preventing errors when encountering a variable\r\n     * or property name that's missing within the formatting parameters.\r\n     *\r\n     * It can also be set to a function, to be called with two parameters that depend on the type of formatting being used,\r\n     * and to return the actual default value:\r\n     *\r\n     * - Named Parameters formatting:\r\n     *   - `name` - name of the property missing in the formatting object\r\n     *   - `obj` - the formatting object, and is the same as `this` context\r\n     *\r\n     * - Regular variable formatting:\r\n     *   - `index` - element's index that's outside of the formatting array's range\r\n     *   - `arr` - the formatting array, and is the same as `this` context\r\n     *\r\n     * @returns {string}\r\n     * Formatted query string.\r\n     *\r\n     * The function will throw an error, if any occurs during formatting.\r\n     */\r\n    format: (query, values, options) => {\r\n        if (query && typeof query.formatDBType === 'function') {\r\n            query = query.formatDBType();\r\n        }\r\n        return $formatQuery(query, values, false, options);\r\n    }\r\n};\r\n\r\nObject.freeze($as);\r\n\r\nmodule.exports = {\r\n    formatQuery: $formatQuery,\r\n    formatFunction: $formatFunction,\r\n    as: $as\r\n};\r\n\r\n/**\r\n * @external Error\r\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\r\n */\r\n\r\n/**\r\n * @external TypeError\r\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError\r\n */\r\n\r\n/**\r\n * @external RangeError\r\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError\r\n */\r\n\r\n","/home/travis/build/npmtest/node-npmtest-pg-promise/node_modules/pg-promise/lib/helpers/index.js":"'use strict';\r\n\r\nvar $npm = {\r\n    concat: require('./methods/concat'),\r\n    insert: require('./methods/insert'),\r\n    update: require('./methods/update'),\r\n    values: require('./methods/values'),\r\n    sets: require('./methods/sets'),\r\n    TableName: require('./tableName'),\r\n    ColumnSet: require('./columnSet'),\r\n    Column: require('./column')\r\n};\r\n\r\n/**\r\n * @namespace helpers\r\n * @description\r\n * Namespace for query-formatting generators, available as `pgp.helpers`, after initializing the library.\r\n *\r\n * It is a set of types and methods for generating queries in a fast, flexible and reliable way.\r\n *\r\n * See also: $[Performance Boost].\r\n *\r\n * @property {function} TableName\r\n * {@link helpers.TableName TableName} class constructor.\r\n *\r\n * @property {function} ColumnSet\r\n * {@link helpers.ColumnSet ColumnSet} class constructor.\r\n *\r\n * @property {function} Column\r\n * {@link helpers.Column Column} class constructor.\r\n *\r\n * @property {function} insert\r\n * {@link helpers.insert insert} static method.\r\n *\r\n * @property {function} update\r\n * {@link helpers.update update} static method.\r\n *\r\n * @property {function} values\r\n * {@link helpers.values values} static method.\r\n *\r\n * @property {function} sets\r\n * {@link helpers.sets sets} static method.\r\n *\r\n * @property {function} concat\r\n * {@link helpers.concat concat} static method.\r\n */\r\nmodule.exports = config => {\r\n    var res = {\r\n        insert: (data, columns, table) => {\r\n            var capSQL = config.options && config.options.capSQL;\r\n            return $npm.insert(data, columns, table, capSQL);\r\n        },\r\n        update: (data, columns, table, options) => {\r\n            var capSQL = config.options && config.options.capSQL;\r\n            return $npm.update(data, columns, table, options, capSQL);\r\n        },\r\n        concat: $npm.concat,\r\n        values: $npm.values,\r\n        sets: $npm.sets,\r\n        TableName: $npm.TableName,\r\n        ColumnSet: $npm.ColumnSet,\r\n        Column: $npm.Column\r\n    };\r\n    Object.freeze(res);\r\n    return res;\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-pg-promise/node_modules/pg-promise/lib/helpers/methods/concat.js":"'use strict';\r\n\r\nvar $npm = {\r\n    format: require('../../formatting').as.format,\r\n    QueryFile: require('../../queryFile')\r\n};\r\n\r\nvar $arr = require('../../array');\r\n\r\n/**\r\n * @method helpers.concat\r\n * @description\r\n * **Added in v.5.3.0**\r\n *\r\n * Concatenates multiple queries into a single query string.\r\n *\r\n * - Before joining each query, the method removes from it all leading and trailing spaces, tabs and semi-colons.\r\n * - Empty queries are skipped automatically.\r\n *\r\n * @param {array<string|helpers.QueryFormat|QueryFile>} queries\r\n * Array of mixed-type elements:\r\n * - a simple query string, to be used as is\r\n * - a {@link helpers.QueryFormat QueryFormat}-like object = `{query, [values], [options]}`\r\n * - a {@link QueryFile} object\r\n *\r\n * @returns {string}\r\n * Concatenated string with all queries.\r\n *\r\n * @example\r\n *\r\n * var pgp = require('pg-promise')();\r\n *\r\n * var qf1 = new pgp.QueryFile('./query1.sql', {minify: true});\r\n * var qf2 = new pgp.QueryFile('./query2.sql', {minify: true});\r\n *\r\n * var query = pgp.helpers.concat([\r\n *     {query: 'INSERT INTO Users(name, age) VALUES($1, $2)', values: ['John', 23]}, // QueryFormat-like object\r\n *     {query: qf1, values: [1, 'Name']}, // QueryFile with formatting parameters\r\n *     'SELECT count(*) FROM Users', // a simple-string query,\r\n *     qf2 // direct QueryFile object\r\n * ]);\r\n *\r\n * // query = concatenated string with all the queries\r\n */\r\nfunction concat(queries) {\r\n    if (!Array.isArray(queries)) {\r\n        throw new TypeError('Parameter \\'queries\\' must be an array.');\r\n    }\r\n    var all = $arr.map(queries, (q, index) => {\r\n        if (typeof q === 'string') {\r\n            // a simple query string without parameters:\r\n            return clean(q);\r\n        }\r\n        if (q && typeof q === 'object') {\r\n            if (q instanceof $npm.QueryFile) {\r\n                // QueryFile object:\r\n                return clean(q.formatDBType());\r\n            }\r\n            if ('query' in q) {\r\n                // object {query, values, options}:\r\n                return clean($npm.format(q.query, q.values, q.options));\r\n            }\r\n        }\r\n        throw new Error('Invalid query element at index ' + index + '.');\r\n    });\r\n\r\n    return $arr.filter(all, q => q).join(';');\r\n}\r\n\r\nfunction clean(q) {\r\n    // removes from the query all leading and trailing symbols ' ', '\\t' and ';'\r\n    return q.replace(/^[\\s;]*|[\\s;]*$/g, '');\r\n}\r\n\r\nmodule.exports = concat;\r\n\r\n/**\r\n * @typedef helpers.QueryFormat\r\n * @description\r\n * A simple structure of parameters to be passed into method {@link formatting.format as.format} exactly as they are.\r\n *\r\n * @property {string|value|object} query\r\n * A query string or a value/object that implements $[Custom Type Formatting], to be formatted according to `values`.\r\n *\r\n * @property {array|object|value} [values]\r\n * Optional formatting parameters for the query.\r\n *\r\n * @property {object} [options]\r\n * Query formatting options, as supported by method {@link formatting.format as.format}.\r\n *\r\n * @see\r\n * {@link formatting.format as.format}\r\n */\r\n","/home/travis/build/npmtest/node-npmtest-pg-promise/node_modules/pg-promise/lib/queryFile.js":"'use strict';\r\n\r\nvar $npm = {\r\n    fs: require('fs'),\r\n    os: require('os'),\r\n    path: require('path'),\r\n    minify: require('pg-minify'),\r\n    utils: require('./utils'),\r\n    format: require('./formatting').as.format,\r\n    QueryFileError: require('./errors/queryFile')\r\n};\r\n\r\n/**\r\n * @constructor QueryFile\r\n * @description\r\n *\r\n * Represents an external SQL file. The type is available from the library's root: `pgp.QueryFile`.\r\n *\r\n * Reads a file with SQL and prepares it for execution, also parses and minifies it, if required.\r\n * The SQL can be of any complexity, with both single and multi-line comments.\r\n *\r\n * The type can be used in place of the `query` parameter, with any query method directly, plus as `text` in {@link PreparedStatement}\r\n * and {@link ParameterizedQuery}.\r\n *\r\n * It never throws any error, leaving it for query methods to reject with {@link errors.QueryFileError QueryFileError}.\r\n *\r\n * For any given SQL file you should only create a single instance of this class throughout the application.\r\n *\r\n * @param {string} file\r\n * Path to the SQL file with the query, either absolute or relative to the application's entry point file.\r\n *\r\n * If there is any problem reading the file, it will be reported when executing the query.\r\n *\r\n * @param {QueryFile.Options} [options]\r\n * Set of configuration options, as documented by {@link QueryFile.Options}.\r\n *\r\n * @returns {QueryFile}\r\n *\r\n * @see\r\n * {@link errors.QueryFileError QueryFileError},\r\n * {@link utils}\r\n *\r\n * @example\r\n * // File sql.js\r\n *\r\n * // Proper way to organize an sql provider:\r\n * //\r\n * // - have all sql files for Users in ./sql/users\r\n * // - have all sql files for Products in ./sql/products\r\n * // - have your sql provider module as ./sql/index.js\r\n *\r\n * var QueryFile = require('pg-promise').QueryFile;\r\n * var path = require('path');\r\n *\r\n * // Helper for linking to external query files:\r\n * function sql(file) {\r\n *     var fullPath = path.join(__dirname, file); // generating full path;\r\n *     return new QueryFile(fullPath, {minify: true});\r\n * }\r\n *\r\n * module.exports = {\r\n *     // external queries for Users:\r\n *     users: {\r\n *         add: sql('users/create.sql'),\r\n *         search: sql('users/search.sql'),\r\n *         report: sql('users/report.sql'),\r\n *     },\r\n *     // external queries for Products:\r\n *     products: {\r\n *         add: sql('products/add.sql'),\r\n *         quote: sql('products/quote.sql'),\r\n *         search: sql('products/search.sql'),\r\n *     }\r\n * };\r\n *\r\n * @example\r\n * // Testing our SQL provider\r\n *\r\n * var db = require('./db'); // our database module;\r\n * var sql = require('./sql').users; // our sql for users;\r\n *\r\n * module.exports = {\r\n *     addUser: (name, age) => db.none(sql.add, [name, age]),\r\n *     findUser: name => db.any(sql.search, name)\r\n * };\r\n *\r\n */\r\nfunction QueryFile(file, options) {\r\n\r\n    if (!(this instanceof QueryFile)) {\r\n        return new QueryFile(file, options);\r\n    }\r\n\r\n    var sql, error, ready, modTime, after, filePath = file, opt = {\r\n        debug: $npm.utils.isDev(),\r\n        minify: false,\r\n        compress: false\r\n    };\r\n\r\n    if (options && typeof options === 'object') {\r\n        if (options.debug !== undefined) {\r\n            opt.debug = !!options.debug;\r\n        }\r\n        if (options.minify !== undefined) {\r\n            after = options.minify === 'after';\r\n            opt.minify = after ? 'after' : !!options.minify;\r\n        }\r\n        if (options.compress !== undefined) {\r\n            opt.compress = !!options.compress;\r\n        }\r\n        if (opt.compress && options.minify === undefined) {\r\n            opt.minify = true;\r\n        }\r\n        if (options.params !== undefined) {\r\n            opt.params = options.params;\r\n        }\r\n    }\r\n\r\n    Object.freeze(opt);\r\n\r\n    if ($npm.utils.isText(filePath) && !$npm.utils.isPathAbsolute(filePath)) {\r\n        filePath = $npm.path.join($npm.utils.startDir, filePath);\r\n    }\r\n\r\n    // Custom Type Formatting support:\r\n    this.formatDBType = function () {\r\n        this.prepare(true);\r\n        return this.query;\r\n    };\r\n\r\n    /**\r\n     * @method QueryFile.prepare\r\n     * @summary Prepares the query for execution.\r\n     * @description\r\n     * If the the query hasn't been prepared yet, it will read the file and process the contents according\r\n     * to the parameters passed into the constructor.\r\n     *\r\n     * This method is primarily for internal use by the library.\r\n     *\r\n     * @param {boolean} [throwErrors=false]\r\n     * Throw any error encountered.\r\n     *\r\n     */\r\n    this.prepare = function (throwErrors) {\r\n        var lastMod;\r\n        if (opt.debug && ready) {\r\n            try {\r\n                lastMod = $npm.fs.statSync(filePath).mtime.getTime();\r\n                if (lastMod === modTime) {\r\n                    // istanbul ignore next;\r\n                    // coverage for this works differently under Windows and Linux\r\n                    return;\r\n                }\r\n                ready = false;\r\n            } catch (e) {\r\n                sql = undefined;\r\n                ready = false;\r\n                error = e;\r\n                if (throwErrors) {\r\n                    throw error;\r\n                }\r\n                return;\r\n            }\r\n        }\r\n        if (ready) {\r\n            return;\r\n        }\r\n        try {\r\n            sql = $npm.fs.readFileSync(filePath, 'utf8');\r\n            modTime = lastMod || $npm.fs.statSync(filePath).mtime.getTime();\r\n            if (opt.minify && !after) {\r\n                sql = $npm.minify(sql, {compress: opt.compress});\r\n            }\r\n            if (opt.params !== undefined) {\r\n                sql = $npm.format(sql, opt.params, {partial: true});\r\n            }\r\n            if (opt.minify && after) {\r\n                sql = $npm.minify(sql, {compress: opt.compress});\r\n            }\r\n            ready = true;\r\n            error = undefined;\r\n        } catch (e) {\r\n            sql = undefined;\r\n            error = new $npm.QueryFileError(e, this);\r\n            if (throwErrors) {\r\n                throw error;\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * @name QueryFile#query\r\n     * @type {string}\r\n     * @default undefined\r\n     * @readonly\r\n     * @summary Prepared query string.\r\n     * @description\r\n     * When property {@link QueryFile#error error} is set, the query is `undefined`.\r\n     *\r\n     * This property is primarily for internal use by the library.\r\n     */\r\n    Object.defineProperty(this, 'query', {\r\n        get: () => sql\r\n    });\r\n\r\n    /**\r\n     * @name QueryFile#error\r\n     * @type {errors.QueryFileError}\r\n     * @default undefined\r\n     * @readonly\r\n     * @description\r\n     * When in an error state, it is set to a {@link errors.QueryFileError QueryFileError} object. Otherwise, it is `undefined`.\r\n     *\r\n     * This property is primarily for internal use by the library.\r\n     */\r\n    Object.defineProperty(this, 'error', {\r\n        get: () => error\r\n    });\r\n\r\n    /**\r\n     * @name QueryFile#file\r\n     * @type {string}\r\n     * @readonly\r\n     * @description\r\n     * File name that was passed into the constructor.\r\n     *\r\n     * This property is primarily for internal use by the library.\r\n     */\r\n    Object.defineProperty(this, 'file', {\r\n        get: () => file\r\n    });\r\n\r\n    /**\r\n     * @name QueryFile#options\r\n     * @type {QueryFile.Options}\r\n     * @readonly\r\n     * @description\r\n     * Set of options, as configured during the object's construction.\r\n     *\r\n     * This property is primarily for internal use by the library.\r\n     */\r\n    Object.defineProperty(this, 'options', {\r\n        get: () => opt\r\n    });\r\n\r\n    this.prepare();\r\n}\r\n\r\n/**\r\n * @method QueryFile.toString\r\n * @description\r\n * Creates a well-formatted multi-line string that represents the object's current state.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * @param {number} [level=0]\r\n * Nested output level, to provide visual offset.\r\n *\r\n * @returns {string}\r\n */\r\nQueryFile.prototype.toString = function (level) {\r\n    level = level > 0 ? parseInt(level) : 0;\r\n    var gap = $npm.utils.messageGap(level + 1);\r\n    var lines = [\r\n        'QueryFile {'\r\n    ];\r\n    this.prepare();\r\n    lines.push(gap + 'file: \"' + this.file + '\"');\r\n    lines.push(gap + 'options: ' + JSON.stringify(this.options));\r\n    if (this.error) {\r\n        lines.push(gap + 'error: ' + this.error.toString(level + 1));\r\n    } else {\r\n        lines.push(gap + 'query: \"' + this.query + '\"');\r\n    }\r\n    lines.push($npm.utils.messageGap(level) + '}');\r\n    return lines.join($npm.os.EOL);\r\n};\r\n\r\nQueryFile.prototype.inspect = function () {\r\n    return this.toString();\r\n};\r\n\r\nmodule.exports = QueryFile;\r\n\r\n/**\r\n * @typedef QueryFile.Options\r\n * @description\r\n * A set of configuration options as passed into the {@link QueryFile} constructor.\r\n *\r\n * @property {boolean} debug\r\n * When in debug mode, the query file is checked for its last modification time on every query request,\r\n * so if it changes, the file is read afresh.\r\n *\r\n * The default for this property is `true` when `NODE_ENV` = `development`,\r\n * or `false` otherwise.\r\n *\r\n * @property {boolean|string} minify=false\r\n * Parses and minifies the SQL using $[pg-minify]:\r\n * - `false` - do not use $[pg-minify]\r\n * - `true` - use $[pg-minify] to parse and minify SQL\r\n * - `'after'` - use $[pg-minify] after applying static formatting parameters\r\n *   (option `params`), as opposed to before it (default)\r\n *\r\n * If option `compress` is set, then the default for `minify` is `true`.\r\n *\r\n * Failure to parse SQL will result in $[SQLParsingError].\r\n *\r\n * @property {boolean} compress=false\r\n * Sets option `compress` as supported by $[pg-minify], to uglify the SQL:\r\n * - `false` - no compression to be applied, keep minimum spaces for easier read\r\n * - `true` - remove all unnecessary spaces from SQL\r\n *\r\n * This option has no meaning, if `minify` is explicitly set to `false`. However, if `minify` is not\r\n * specified and `compress` is specified as `true`, then `minify` defaults to `true`.\r\n *\r\n * @property {array|object|value} params\r\n *\r\n * Static formatting parameters to be applied to the SQL, using the same method {@link formatting.format as.format},\r\n * but with option `partial` = `true`.\r\n *\r\n * Most of the time query formatting is fully dynamic, and applied just before executing the query.\r\n * In some cases though you may need to pre-format SQL with static values. Examples of it can be a\r\n * schema name, or a configurable table name.\r\n *\r\n * This option makes two-step SQL formatting easy: you can pre-format the SQL initially, and then\r\n * apply the second-step dynamic formatting when executing the query.\r\n */\r\n","/home/travis/build/npmtest/node-npmtest-pg-promise/node_modules/pg-promise/lib/utils/index.js":"'use strict';\r\n\r\nvar $path = require('path');\r\n\r\n////////////////////////////////////////////\r\n// Simpler check for null/undefined;\r\nfunction isNull(value) {\r\n    return value === null || value === undefined;\r\n}\r\n\r\n////////////////////////////////////////////////////////\r\n// Verifies parameter for being a non-empty text string;\r\nfunction isText(txt) {\r\n    return txt && typeof txt === 'string' && /\\S/.test(txt);\r\n}\r\n\r\n//////////////////////////////////////\r\n// Verifies value for being an object,\r\n// based on type and property names.\r\nfunction isObject(value, properties) {\r\n    if (value && typeof value === 'object') {\r\n        for (var i = 0; i < properties.length; i++) {\r\n            if (!(properties[i] in value)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n///////////////////////////////////////////////////////////\r\n// Approximates the environment as being for development.\r\n//\r\n// Proper configuration is having NODE_ENV = 'development', but this\r\n// method only checks for 'dev' being present, and regardless of the case.\r\nfunction isDev() {\r\n    var env = global.process.env.NODE_ENV || '';\r\n    return env.toLowerCase().indexOf('dev') !== -1;\r\n}\r\n\r\n///////////////////////////////////////////////////\r\n// Locks all properties in an object to read-only,\r\n// or freezes the entire object for any changes.\r\nfunction lock(obj, freeze, options) {\r\n    if (options && options.noLocking) {\r\n        return;\r\n    }\r\n    if (freeze) {\r\n        Object.freeze(obj); // freeze the entire object, permanently;\r\n    } else {\r\n        var desc = {\r\n            writable: false,\r\n            configurable: false,\r\n            enumerable: true\r\n        };\r\n        for (var p in obj) {\r\n            Object.defineProperty(obj, p, desc);\r\n        }\r\n    }\r\n}\r\n\r\n/////////////////////////////////////////////\r\n// Adds properties from source to the target,\r\n// making them read-only and enumerable.\r\nfunction addReadProperties(target, source) {\r\n    for (var p in source) {\r\n        addReadProp(target, p, source[p]);\r\n    }\r\n}\r\n\r\n///////////////////////////////////////////////////////\r\n// Adds a read-only, non-deletable enumerable property.\r\nfunction addReadProp(obj, name, value, hidden) {\r\n    Object.defineProperty(obj, name, {\r\n        value: value,\r\n        configurable: false,\r\n        enumerable: !hidden,\r\n        writable: false\r\n    });\r\n}\r\n\r\n//////////////////////////////////////////////////////////////\r\n// Converts a connection string or object into its safe copy:\r\n// if password is present, it is masked with symbol '#'.\r\nfunction getSafeConnection(cn) {\r\n    if (typeof cn === 'object') {\r\n        var copy = JSON.parse(JSON.stringify(cn));\r\n        if (typeof copy.password === 'string') {\r\n            copy.password = copy.password.replace(/./g, '#');\r\n        }\r\n        return copy;\r\n    }\r\n    // or else it is a connection string;\r\n    return cn.replace(/:(?![\\/])([^@]+)/, (_, m) => {\r\n        return ':' + new Array(m.length + 1).join('#');\r\n    });\r\n}\r\n\r\n///////////////////////////////////////////\r\n// Returns a space gap for console output;\r\nfunction messageGap(level) {\r\n    return Array(1 + level * 4).join(' ');\r\n}\r\n\r\n/////////////////////////////////////////\r\n// Provides platform-neutral inheritance;\r\nfunction inherits(child, parent) {\r\n    child.prototype.__proto__ = parent.prototype;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n// Checks if the path is absolute;\r\n//\r\n// We exclude this from the coverage, because the code is platform-specific,\r\n// and while most of its code is for Windows, Travis CI is a linux platform.\r\n//\r\n// istanbul ignore next\r\nfunction isPathAbsolute(path) {\r\n    // Based on: https://github.com/sindresorhus/path-is-absolute\r\n    if (process.platform === 'win32') {\r\n        var splitDeviceRe = /^([a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/]+[^\\\\\\/]+)?([\\\\\\/])?([\\s\\S]*?)$/;\r\n        var result = splitDeviceRe.exec(path);\r\n        var device = result[1] || '';\r\n        var isUnc = !!device && device.charAt(1) !== ':';\r\n        return !!result[2] || isUnc;\r\n    }\r\n    return path.charAt(0) === '/';\r\n}\r\n\r\nfunction getLocalStack(startIdx) {\r\n    // from the call stack, we take only lines starting with the client's\r\n    // source code, and only those that contain a full path inside brackets,\r\n    // indicating a reference to the client's source code:\r\n    return new Error().stack.split('\\n').slice(startIdx).filter(line => {\r\n        return line.match(/\\(.*(\\\\+|\\/+).*\\)/); // contains \\ or / inside ()\r\n    }).join('\\n');\r\n}\r\n\r\n//////////////////////////////\r\n// Internal error container;\r\nfunction InternalError(error) {\r\n    this.error = error;\r\n}\r\n\r\nvar exp = {\r\n    InternalError: InternalError,\r\n    getLocalStack: getLocalStack,\r\n    isPathAbsolute: isPathAbsolute,\r\n    lock: lock,\r\n    isText: isText,\r\n    isNull: isNull,\r\n    isDev: isDev,\r\n    isObject: isObject,\r\n    addReadProp: addReadProp,\r\n    addReadProperties: addReadProperties,\r\n    getSafeConnection: getSafeConnection,\r\n    messageGap: messageGap,\r\n    inherits: inherits\r\n};\r\n\r\nvar mainFile = process.argv[1];\r\n\r\n// istanbul ignore next\r\nexp.startDir = mainFile ? $path.dirname(mainFile) : process.cwd();\r\n\r\nObject.freeze(exp);\r\n\r\nmodule.exports = exp;\r\n","/home/travis/build/npmtest/node-npmtest-pg-promise/node_modules/pg-promise/lib/errors/queryFile.js":"'use strict';\r\n\r\nvar $npm = {\r\n    os: require('os'),\r\n    utils: require('../utils'),\r\n    minify: require('pg-minify')\r\n};\r\n\r\n/**\r\n * @interface errors.QueryFileError\r\n * @augments external:Error\r\n * @description\r\n * {@link errors.QueryFileError QueryFileError} interface, available from the {@link errors} namespace.\r\n *\r\n * This type represents all errors related to {@link QueryFile}.\r\n *\r\n * @property {string} name\r\n * Standard {@link external:Error Error} property - error type name = `QueryFileError`.\r\n *\r\n * @property {string} message\r\n * Standard {@link external:Error Error} property - the error message.\r\n *\r\n * @property {string} stack\r\n * Standard {@link external:Error Error} property - the stack trace.\r\n *\r\n * @property {string} file\r\n * File path/name that was passed into the {@link QueryFile} constructor.\r\n *\r\n * @property {object} options\r\n * Set of options that was used by the {@link QueryFile} object.\r\n *\r\n * @property {SQLParsingError} error\r\n * Internal $[SQLParsingError] object.\r\n *\r\n * It is set only when the error was thrown by $[pg-minify] while parsing the SQL file.\r\n *\r\n * @see QueryFile\r\n *\r\n */\r\nfunction QueryFileError(error, qf) {\r\n    var temp = Error.apply(this, arguments);\r\n    temp.name = this.name = 'QueryFileError';\r\n    this.stack = temp.stack;\r\n    if (error instanceof $npm.minify.SQLParsingError) {\r\n        this.error = error;\r\n        this.message = 'Failed to parse the SQL.';\r\n    } else {\r\n        this.message = error.message;\r\n    }\r\n    this.file = qf.file;\r\n    this.options = qf.options;\r\n}\r\n\r\nQueryFileError.prototype = Object.create(Error.prototype, {\r\n    constructor: {\r\n        value: QueryFileError,\r\n        writable: true,\r\n        configurable: true\r\n    }\r\n});\r\n\r\n/**\r\n * @method errors.QueryFileError.toString\r\n * @description\r\n * Creates a well-formatted multi-line string that represents the error.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * @param {number} [level=0]\r\n * Nested output level, to provide visual offset.\r\n *\r\n * @returns {string}\r\n */\r\nQueryFileError.prototype.toString = function (level) {\r\n    level = level > 0 ? parseInt(level) : 0;\r\n    var gap0 = $npm.utils.messageGap(level),\r\n        gap1 = $npm.utils.messageGap(level + 1),\r\n        lines = [\r\n            'QueryFileError {',\r\n            gap1 + 'message: \"' + this.message + '\"',\r\n            gap1 + 'options: ' + JSON.stringify(this.options),\r\n            gap1 + 'file: \"' + this.file + '\"'\r\n        ];\r\n    if (this.error) {\r\n        lines.push(gap1 + 'error: ' + this.error.toString(level + 1));\r\n    }\r\n    lines.push(gap0 + '}');\r\n    return lines.join($npm.os.EOL);\r\n};\r\n\r\nQueryFileError.prototype.inspect = function () {\r\n    return this.toString();\r\n};\r\n\r\nmodule.exports = QueryFileError;\r\n\r\n","/home/travis/build/npmtest/node-npmtest-pg-promise/node_modules/pg-promise/lib/helpers/methods/insert.js":"'use strict';\r\n\r\nvar $npm = {\r\n    TableName: require('../tableName'),\r\n    ColumnSet: require('../columnSet'),\r\n    formatting: require('../../formatting'),\r\n    utils: require('../../utils')\r\n};\r\n\r\nvar $arr = require('../../array');\r\n\r\n/**\r\n * @method helpers.insert\r\n * @description\r\n * Generates an `INSERT` query for either one object or an array of objects.\r\n *\r\n * @param {object|object[]} data\r\n * An insert object with properties for insert values, or an array of such objects.\r\n *\r\n * When `data` is not a non-null object and not an array, it will throw {@link external:TypeError TypeError} = `Invalid parameter 'data' specified.`\r\n *\r\n * When `data` is an empty array, it will throw {@link external:TypeError TypeError} = `Cannot generate an INSERT from an empty array.`\r\n *\r\n * When `data` is an array that contains a non-object value, the method will throw {@link external:Error Error} =\r\n * `Invalid insert object at index N.`\r\n *\r\n * @param {array|helpers.Column|helpers.ColumnSet} [columns]\r\n * Set of columns to be inserted.\r\n *\r\n * It is optional when `data` is a single object, and required when `data` is an array of objects. If not specified for an array\r\n * of objects, the method will throw {@link external:TypeError TypeError} = `Parameter 'columns' is required when inserting multiple records.`\r\n *\r\n * When `columns` is not a {@link helpers.ColumnSet ColumnSet} object, a temporary {@link helpers.ColumnSet ColumnSet}\r\n * is created - from the value of `columns` (if it was specified), or from the value of `data` (if it is not an array).\r\n *\r\n * When the final {@link helpers.ColumnSet ColumnSet} is empty (no columns in it), the method will throw\r\n * {@link external:Error Error} = `Cannot generate an INSERT without any columns.`\r\n *\r\n * @param {helpers.TableName|string|{table,schema}} [table]\r\n * Destination table.\r\n *\r\n * It is normally a required parameter. But when `columns` is passed in as a {@link helpers.ColumnSet ColumnSet} object\r\n * with `table` set in it, that will be used when this parameter isn't specified. When neither is available, the method\r\n * will throw {@link external:Error Error} = `Table name is unknown.`\r\n *\r\n * @returns {string}\r\n * The resulting query string.\r\n *\r\n * @see\r\n *  {@link helpers.Column Column},\r\n *  {@link helpers.ColumnSet ColumnSet},\r\n *  {@link helpers.TableName TableName}\r\n *\r\n * @example\r\n *\r\n * var pgp = require('pg-promise')({\r\n *    capSQL: true // if you want all generated SQL capitalized\r\n * });\r\n *\r\n * var dataSingle = {val: 123, msg: 'hello'};\r\n * var dataMulti = [{val: 123, msg: 'hello'}, {val: 456, msg: 'world!'}];\r\n *\r\n * // Column details can be taken from the data object:\r\n *\r\n * pgp.helpers.insert(dataSingle, null, 'my-table');\r\n * //=> INSERT INTO \"my-table\"(\"val\",\"msg\") VALUES(123,'hello')\r\n *\r\n * @example\r\n *\r\n * // Column details are required for a multi-row `INSERT`:\r\n *\r\n * pgp.helpers.insert(dataMulti, ['val', 'msg'], 'my-table');\r\n * //=> INSERT INTO \"my-table\"(\"val\",\"msg\") VALUES(123,'hello'),(456,'world!')\r\n *\r\n * @example\r\n *\r\n * // Column details from a reusable ColumnSet (recommended for performance):\r\n *\r\n * var cs = new pgp.helpers.ColumnSet(['val', 'msg'], {table: 'my-table'});\r\n *\r\n * pgp.helpers.insert(dataMulti, cs);\r\n * //=> INSERT INTO \"my-table\"(\"val\",\"msg\") VALUES(123,'hello'),(456,'world!')\r\n *\r\n */\r\nfunction insert(data, columns, table, capSQL) {\r\n\r\n    if (!data || typeof data !== 'object') {\r\n        throw new TypeError('Invalid parameter \\'data\\' specified.');\r\n    }\r\n\r\n    var isArray = Array.isArray(data);\r\n\r\n    if (isArray && !data.length) {\r\n        throw new TypeError('Cannot generate an INSERT from an empty array.');\r\n    }\r\n\r\n    if (columns instanceof $npm.ColumnSet) {\r\n        if ($npm.utils.isNull(table)) {\r\n            table = columns.table;\r\n        }\r\n    } else {\r\n        if (isArray && $npm.utils.isNull(columns)) {\r\n            throw new TypeError('Parameter \\'columns\\' is required when inserting multiple records.');\r\n        }\r\n        columns = new $npm.ColumnSet(columns || data);\r\n    }\r\n\r\n    if (!columns.columns.length) {\r\n        throw new Error('Cannot generate an INSERT without any columns.');\r\n    }\r\n\r\n    if (!table) {\r\n        throw new Error('Table name is unknown.');\r\n    }\r\n\r\n    if (!(table instanceof $npm.TableName)) {\r\n        table = new $npm.TableName(table);\r\n    }\r\n\r\n    var query = capSQL ? sql.capCase : sql.lowCase;\r\n\r\n    var format = $npm.formatting.as.format;\r\n    query = format(query, [table.name, columns.names]);\r\n\r\n    if (isArray) {\r\n        return query + $arr.map(data, (d, index) => {\r\n                if (!d || typeof d !== 'object') {\r\n                    throw new Error('Invalid insert object at index ' + index + '.');\r\n                }\r\n                return '(' + format(columns.variables, columns.prepare(d)) + ')';\r\n            }).join();\r\n    }\r\n    return query + '(' + format(columns.variables, columns.prepare(data)) + ')';\r\n}\r\n\r\nvar sql = {\r\n    lowCase: 'insert into $1^($2^) values',\r\n    capCase: 'INSERT INTO $1^($2^) VALUES'\r\n};\r\n\r\nmodule.exports = insert;\r\n","/home/travis/build/npmtest/node-npmtest-pg-promise/node_modules/pg-promise/lib/helpers/tableName.js":"'use strict';\r\n\r\nvar $npm = {\r\n    utils: require('../utils'),\r\n    formatting: require('../formatting')\r\n};\r\n\r\n/**\r\n * @class helpers.TableName\r\n * @description\r\n *\r\n * **Alternative Syntax:** `TableName({table, [schema]})` &#8658; {@link helpers.TableName}\r\n *\r\n * Prepares and escapes a full table name that can be injected into queries directly.\r\n *\r\n * This is a read-only type that can be used wherever parameter `table` is supported.\r\n *\r\n * It supports $[Custom Type Formatting], which means you can use the type directly as a formatting\r\n * parameter, without specifying any escaping.\r\n *\r\n * @param {String|Object} table\r\n * Table name details, depending on the type:\r\n *\r\n * - table name, if `table` is a string\r\n * - object `{table, [schema]}`\r\n *\r\n * @param {string} [schema]\r\n * Database schema name.\r\n *\r\n * When `table` is passed in as `{table, [schema]}`, this parameter is ignored.\r\n *\r\n * @property {string} name\r\n * Formatted/escaped full table name, based on properties `schema` + `table`.\r\n *\r\n * @property {string} table\r\n * Table name.\r\n *\r\n * @property {string} schema\r\n * Database schema name.\r\n *\r\n * It is `undefined` when no schema was specified (or if it was an empty string).\r\n *\r\n * @returns {helpers.TableName}\r\n *\r\n * @example\r\n *\r\n * var table = new pgp.helpers.TableName('my-table', 'my-schema');\r\n * console.log(table);\r\n * //=> \"my-schema\".\"my-table\"\r\n *\r\n * // Formatting the type directly:\r\n * pgp.as.format(\"SELECT * FROM $1\", table);\r\n * //=> SELECT * FROM \"my-schema\".\"my-table\"\r\n *\r\n */\r\nfunction TableName(table, schema) {\r\n\r\n    if (!(this instanceof TableName)) {\r\n        return new TableName(table, schema);\r\n    }\r\n\r\n    if (table && typeof table === 'object' && 'table' in table) {\r\n        schema = table.schema;\r\n        table = table.table;\r\n    }\r\n\r\n    if (!$npm.utils.isText(table)) {\r\n        throw new TypeError('Table name must be a non-empty text string.');\r\n    }\r\n\r\n    if (!$npm.utils.isNull(schema)) {\r\n        if (typeof schema !== 'string') {\r\n            throw new TypeError('Invalid schema name.');\r\n        }\r\n        if (schema.length > 0) {\r\n            this.schema = schema;\r\n        }\r\n    }\r\n\r\n    this.table = table;\r\n    this.name = $npm.formatting.as.name(table);\r\n\r\n    if (this.schema) {\r\n        this.name = $npm.formatting.as.name(schema) + '.' + this.name;\r\n    }\r\n\r\n    this._rawDBType = true;\r\n\r\n    Object.freeze(this);\r\n}\r\n\r\nTableName.prototype.formatDBType = function () {\r\n    return this.name;\r\n};\r\n\r\n/**\r\n * @method helpers.TableName.toString\r\n * @description\r\n * Creates a well-formatted string that represents the object.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * @returns {string}\r\n */\r\nTableName.prototype.toString = function () {\r\n    return this.name;\r\n};\r\n\r\nTableName.prototype.inspect = function () {\r\n    return this.toString();\r\n};\r\n\r\nmodule.exports = TableName;\r\n","/home/travis/build/npmtest/node-npmtest-pg-promise/node_modules/pg-promise/lib/helpers/columnSet.js":"'use strict';\r\n\r\nvar $npm = {\r\n    os: require('os'),\r\n    utils: require('../utils'),\r\n    formatting: require('../formatting'),\r\n    TableName: require('./tableName'),\r\n    Column: require('./column')\r\n};\r\n\r\nvar $arr = require('../array');\r\n\r\n/**\r\n * @class helpers.ColumnSet\r\n * @description\r\n *\r\n * Performance-optimized, read-only structure with query-formatting columns.\r\n *\r\n * For performance-oriented applications this type should be created globally, to be reused by all methods.\r\n *\r\n * @param {object|helpers.Column|array} columns\r\n * Columns information object, depending on the type:\r\n *\r\n * - When it is a simple object, its properties are enumerated to represent both column names and property names\r\n *   within the source objects. See also option `inherit` that's applicable in this case.\r\n *\r\n * - When it is a single {@link helpers.Column Column} object, property {@link helpers.ColumnSet#columns columns} is initialized with\r\n *   just a single column. It is not a unique situation when only a single column is required for an update operation.\r\n *\r\n * - When it is an array, each element is assumed to represent details for a column. If the element is already of type {@link helpers.Column Column},\r\n *   it is used directly; otherwise the element is passed into {@link helpers.Column Column} constructor for initialization.\r\n *   On any duplicate column name (case-sensitive) it will throw {@link external:Error Error} = `Duplicate column name \"name\".`\r\n *\r\n * - When it is none of the above, it will throw {@link external:TypeError TypeError} = `Invalid parameter 'columns' specified.`\r\n *\r\n * @param {object} [options]\r\n *\r\n * @param {helpers.TableName|string|{table,schema}} [options.table]\r\n * Table details.\r\n *\r\n * When it is a non-null value, and not a {@link helpers.TableName TableName} object, a new {@link helpers.TableName TableName} is constructed from the value.\r\n *\r\n * It can be used as the default for methods {@link helpers.insert insert} and {@link helpers.update update} when their parameter\r\n * `table` is omitted, and for logging purposes.\r\n *\r\n * @param {boolean} [options.inherit = false]\r\n * Use inherited properties in addition to the object's own properties.\r\n *\r\n * By default, only the object's own properties are enumerated for column names.\r\n *\r\n * @returns {helpers.ColumnSet}\r\n *\r\n * @see\r\n *\r\n * {@link helpers.ColumnSet#columns columns},\r\n * {@link helpers.ColumnSet#names names},\r\n * {@link helpers.ColumnSet#table table},\r\n * {@link helpers.ColumnSet#variables variables} |\r\n * {@link helpers.ColumnSet.extend extend},\r\n * {@link helpers.ColumnSet.merge merge},\r\n * {@link helpers.ColumnSet.prepare prepare}\r\n *\r\n * @example\r\n *\r\n * // A complex insert/update object scenario for table 'purchases' in schema 'fiscal'.\r\n * // For a good performance, you should declare such objects once and then reuse them.\r\n * //\r\n * // Column Requirements:\r\n * //\r\n * // 1. Property 'id' is only to be used for a WHERE condition in updates\r\n * // 2. Property 'list' needs to be formatted as a csv\r\n * // 3. Property 'code' is to be used as raw text, and to be defaulted to 0 when the\r\n * //    property is missing in the source object\r\n * // 4. Property 'log' is a JSON object with 'log-entry' for the column name\r\n * // 5. Property 'data' requires SQL type casting '::int[]'\r\n * // 6. Property 'amount' needs to be set to 100, if it is 0\r\n * // 7. Property 'total' must be skipped during updates, if 'amount' was 0, plus its\r\n * //    column name is 'total-val'\r\n *\r\n * var cs = new pgp.helpers.ColumnSet([\r\n *     '?id', // ColumnConfig equivalent: {name: 'id', cnd: true}\r\n *     'list:csv', // ColumnConfig equivalent: {name: 'list', mod: ':csv'}\r\n *     {\r\n *         name: 'code',\r\n *         mod: '^', // format as raw text\r\n *         def: 0 // default to 0 when the property doesn't exist\r\n *     },\r\n *     {\r\n *         name: 'log-entry',\r\n *         prop: 'log',\r\n *         mod: ':json' // format as JSON\r\n *     },\r\n *     {\r\n *         name: 'data',\r\n *         cast: 'int[]' // use SQL type casting '::int[]'\r\n *     },\r\n *     {\r\n *         name: 'amount',\r\n *         init: col => {\r\n *             // set to 100, if the value is 0:\r\n *             return col.value === 0 ? 100 : col.value;\r\n *         }\r\n *     },\r\n *     {\r\n *         name: 'total-val',\r\n *         prop: 'total',\r\n *         skip: col => {\r\n *             // skip from updates, if 'amount' is 0:\r\n *             return col.source.amount === 0;\r\n *         }\r\n *     }\r\n * ], {table: {table: 'purchases', schema: 'fiscal'}});\r\n *\r\n * // Alternatively, you could take the table declaration out:\r\n * // var table = new pgp.helpers.TableName('purchases', 'fiscal');\r\n *\r\n * console.log(cs); // console output for the object:\r\n * //=>\r\n * // ColumnSet {\r\n * //    table: \"fiscal\".\"purchases\"\r\n * //    columns: [\r\n * //        Column {\r\n * //            name: \"id\"\r\n * //            cnd: true\r\n * //        }\r\n * //        Column {\r\n * //            name: \"list\"\r\n * //            mod: \":csv\"\r\n * //        }\r\n * //        Column {\r\n * //            name: \"code\"\r\n * //            mod: \"^\"\r\n * //            def: 0\r\n * //        }\r\n * //        Column {\r\n * //            name: \"log-entry\"\r\n * //            prop: \"log\"\r\n * //            mod: \":json\"\r\n * //        }\r\n * //        Column {\r\n * //            name: \"data\"\r\n * //            cast: \"int[]\"\r\n * //        }\r\n * //        Column {\r\n * //            name: \"amount\"\r\n * //            init: [Function]\r\n * //        }\r\n * //        Column {\r\n * //            name: \"total-val\"\r\n * //            prop: \"total\"\r\n * //            skip: [Function]\r\n * //        }\r\n * //    ]\r\n * // }\r\n */\r\nfunction ColumnSet(columns, options) {\r\n\r\n    if (!(this instanceof ColumnSet)) {\r\n        return new ColumnSet(columns, options);\r\n    }\r\n\r\n    if (!columns || typeof columns !== 'object') {\r\n        throw new TypeError('Invalid parameter \\'columns\\' specified.');\r\n    }\r\n\r\n    var inherit, names, variables, updates, isSimple = true;\r\n\r\n    if (!$npm.utils.isNull(options)) {\r\n        if (typeof options !== 'object') {\r\n            throw new TypeError('Invalid parameter \\'options\\' specified.');\r\n        }\r\n        if (!$npm.utils.isNull(options.table)) {\r\n            if (options.table instanceof $npm.TableName) {\r\n                this.table = options.table;\r\n            } else {\r\n                this.table = new $npm.TableName(options.table);\r\n            }\r\n        }\r\n        inherit = options.inherit;\r\n    }\r\n\r\n    /**\r\n     * @name helpers.ColumnSet#table\r\n     * @type {helpers.TableName}\r\n     * @readonly\r\n     * @description\r\n     * Destination table. It can be specified for two purposes:\r\n     *\r\n     * - **primary:** to be used as the default table when it is omitted during a call into methods {@link helpers.insert insert} and {@link helpers.update update}\r\n     * - **secondary:** to be automatically written into the console (for logging purposes).\r\n     */\r\n\r\n\r\n    /**\r\n     * @name helpers.ColumnSet#columns\r\n     * @type helpers.Column[]\r\n     * @readonly\r\n     * @description\r\n     * Array of {@link helpers.Column Column} objects.\r\n     */\r\n    if (Array.isArray(columns)) {\r\n        var colNames = {};\r\n        this.columns = $arr.map(columns, c => {\r\n            var col = (c instanceof $npm.Column) ? c : new $npm.Column(c);\r\n            if (col.name in colNames) {\r\n                throw new Error('Duplicate column name \"' + col.name + '\".');\r\n            }\r\n            colNames[col.name] = true;\r\n            return col;\r\n        });\r\n    } else {\r\n        if (columns instanceof $npm.Column) {\r\n            this.columns = [columns];\r\n        } else {\r\n            this.columns = [];\r\n            for (var name in columns) {\r\n                if (inherit || Object.prototype.hasOwnProperty.call(columns, name)) {\r\n                    this.columns.push(new $npm.Column(name));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    Object.freeze(this.columns);\r\n\r\n    for (var i = 0; i < this.columns.length; i++) {\r\n        var c = this.columns[i];\r\n        // ColumnSet is simple when the source objects require no preparation,\r\n        // and should be used directly:\r\n        if (c.prop || c.init || 'def' in c) {\r\n            isSimple = false;\r\n            break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @name helpers.ColumnSet#names\r\n     * @type String\r\n     * @readonly\r\n     * @description\r\n     * **Added in v5.5.5**\r\n     *\r\n     * Returns a string - comma-separated list of all column names, properly escaped.\r\n     *\r\n     * This method is primarily for internal use.\r\n     *\r\n     * @example\r\n     * var cs = new ColumnSet(['id^', {name: 'cells', cast: 'int[]'}, 'doc:json']);\r\n     * console.log(cs.names);\r\n     * //=> \"id\",\"cells\",\"doc\"\r\n     */\r\n    Object.defineProperty(this, 'names', {\r\n        get: () => {\r\n            if (!names) {\r\n                names = $arr.map(this.columns, c => c.escapedName).join();\r\n            }\r\n            return names;\r\n        }\r\n    });\r\n\r\n    /**\r\n     * @name helpers.ColumnSet#variables\r\n     * @type String\r\n     * @readonly\r\n     * @description\r\n     * **Added in v5.5.5**\r\n     *\r\n     * Returns a string - formatting template for all column values.\r\n     *\r\n     * This method is primarily for internal use.\r\n     *\r\n     * @example\r\n     * var cs = new ColumnSet(['id^', {name: 'cells', cast: 'int[]'}, 'doc:json']);\r\n     * console.log(cs.variables);\r\n     * //=> ${id^},${cells}::int[],${doc:json}\r\n     */\r\n    Object.defineProperty(this, 'variables', {\r\n        get: () => {\r\n            if (!variables) {\r\n                variables = $arr.map(this.columns, c => c.variable + c.castText).join();\r\n            }\r\n            return variables;\r\n        }\r\n    });\r\n\r\n    /**\r\n     * @method helpers.ColumnSet.assign\r\n     * @private\r\n     * @description\r\n     * Returns a formatting template of SET assignments for a single object.\r\n     *\r\n     * This method is for internal use only.\r\n     *\r\n     * @param {object} source\r\n     * Source object that contains values for columns.\r\n     *\r\n     * @returns {string}\r\n     * Comma-separated list of variable-to-column assignments.\r\n     */\r\n    this.assign = source => {\r\n        if (updates) {\r\n            return updates;\r\n        }\r\n        var dynamic;\r\n        var list = $arr.filter(this.columns, c => {\r\n            if (c.cnd) {\r\n                return false;\r\n            }\r\n            if (c.skip) {\r\n                dynamic = true;\r\n                var a = colDesc(c, source);\r\n                if (c.skip.call(source, a)) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        });\r\n\r\n        list = $arr.map(list, c => c.escapedName + '=' + c.variable + c.castText).join();\r\n\r\n        if (!dynamic) {\r\n            updates = list;\r\n        }\r\n        return list;\r\n    };\r\n\r\n    /**\r\n     * @method helpers.ColumnSet.extend\r\n     * @description\r\n     * Creates a new {@link helpers.ColumnSet ColumnSet}, by joining the two sets of columns.\r\n     *\r\n     * If the two sets contain a column with the same `name` (case-sensitive), an error is thrown.\r\n     *\r\n     * @param {helpers.Column|helpers.ColumnSet|array} columns\r\n     * Columns to be appended, of the same type as parameter `columns` during {@link helpers.ColumnSet ColumnSet} construction, except:\r\n     * - it can also be of type {@link helpers.ColumnSet ColumnSet}\r\n     * - it cannot be a simple object (properties enumeration is not supported here)\r\n     *\r\n     * @returns {helpers.ColumnSet}\r\n     * New {@link helpers.ColumnSet ColumnSet} object with the extended/concatenated list of columns.\r\n     *\r\n     * @see\r\n     * {@link helpers.Column Column},\r\n     * {@link helpers.ColumnSet.merge merge}\r\n     *\r\n     * @example\r\n     *\r\n     * var pgp = require('pg-promise')();\r\n     *\r\n     * var cs = new pgp.helpers.ColumnSet(['one', 'two'], {table: 'my-table'});\r\n     * console.log(cs);\r\n     * //=>\r\n     * // ColumnSet {\r\n     * //    table: \"my-table\"\r\n     * //    columns: [\r\n     * //        Column {\r\n     * //            name: \"one\"\r\n     * //        }\r\n     * //        Column {\r\n     * //            name: \"two\"\r\n     * //        }\r\n     * //    ]\r\n     * // }\r\n     * var csExtended = cs.extend(['three']);\r\n     * console.log(csExtended);\r\n     * //=>\r\n     * // ColumnSet {\r\n     * //    table: \"my-table\"\r\n     * //    columns: [\r\n     * //        Column {\r\n     * //            name: \"one\"\r\n     * //        }\r\n     * //        Column {\r\n     * //            name: \"two\"\r\n     * //        }\r\n     * //        Column {\r\n     * //            name: \"three\"\r\n     * //        }\r\n     * //    ]\r\n     * // }\r\n     */\r\n    this.extend = columns => {\r\n        var cs = columns;\r\n        if (!(cs instanceof ColumnSet)) {\r\n            cs = new ColumnSet(columns);\r\n        }\r\n        // Any duplicate column will throw Error = 'Duplicate column name \"name\".',\r\n        return new ColumnSet(this.columns.concat(cs.columns), {table: this.table});\r\n    };\r\n\r\n    /**\r\n     * @method helpers.ColumnSet.merge\r\n     * @description\r\n     * Creates a new {@link helpers.ColumnSet ColumnSet}, by joining the two sets of columns.\r\n     *\r\n     * Items in `columns` with the same `name` (case-sensitive) override the original columns.\r\n     *\r\n     * @param {helpers.Column|helpers.ColumnSet|array} columns\r\n     * Columns to be appended, of the same type as parameter `columns` during {@link helpers.ColumnSet ColumnSet} construction, except:\r\n     * - it can also be of type {@link helpers.ColumnSet ColumnSet}\r\n     * - it cannot be a simple object (properties enumeration is not supported here)\r\n     *\r\n     * @see\r\n     * {@link helpers.Column Column},\r\n     * {@link helpers.ColumnSet.extend extend}\r\n     *\r\n     * @returns {helpers.ColumnSet}\r\n     * New {@link helpers.ColumnSet ColumnSet} object with the merged list of columns.\r\n     *\r\n     * @example\r\n     *\r\n     * var pgp = require('pg-promise')();\r\n     *\r\n     * var cs = new pgp.helpers.ColumnSet(['?one', 'two:json'], {table: 'my-table'});\r\n     * console.log(cs);\r\n     * //=>\r\n     * // ColumnSet {\r\n     * //    table: \"my-table\"\r\n     * //    columns: [\r\n     * //        Column {\r\n     * //            name: \"one\"\r\n     * //            cnd: true\r\n     * //        }\r\n     * //        Column {\r\n     * //            name: \"two\"\r\n     * //            mod: \":json\"\r\n     * //        }\r\n     * //    ]\r\n     * // }\r\n     * var csMerged = cs.merge(['two', 'three^']);\r\n     * console.log(csMerged);\r\n     * //=>\r\n     * // ColumnSet {\r\n     * //    table: \"my-table\"\r\n     * //    columns: [\r\n     * //        Column {\r\n     * //            name: \"one\"\r\n     * //            cnd: true\r\n     * //        }\r\n     * //        Column {\r\n     * //            name: \"two\"\r\n     * //        }\r\n     * //        Column {\r\n     * //            name: \"three\"\r\n     * //            mod: \"^\"\r\n     * //        }\r\n     * //    ]\r\n     * // }\r\n     *\r\n     */\r\n    this.merge = columns => {\r\n        var cs = columns;\r\n        if (!(cs instanceof ColumnSet)) {\r\n            cs = new ColumnSet(columns);\r\n        }\r\n        var colNames = {}, cols = [];\r\n        $arr.forEach(this.columns, (c, idx) => {\r\n            cols.push(c);\r\n            colNames[c.name] = idx;\r\n        });\r\n        $arr.forEach(cs.columns, c => {\r\n            if (c.name in colNames) {\r\n                cols[colNames[c.name]] = c;\r\n            } else {\r\n                cols.push(c);\r\n            }\r\n        });\r\n        return new ColumnSet(cols, {table: this.table});\r\n    };\r\n\r\n    /**\r\n     * @method helpers.ColumnSet.prepare\r\n     * @description\r\n     * **Added in v5.5.6**\r\n     *\r\n     * Prepares a source object to be formatted, by cloning it and applying the rules\r\n     * as set by the columns configuration.\r\n     *\r\n     * This method is primarily for internal use, and as such it does not validate\r\n     * its input parameters.\r\n     *\r\n     * @param {object} source\r\n     * The source object to be prepared, if required.\r\n     *\r\n     * It must be a non-`null` object, which the method does not validate, as it is\r\n     * intended primarily for internal use by the library.\r\n     *\r\n     * @returns {object}\r\n     * When the object needs to be prepared, the method returns a clone of the source object,\r\n     * with all properties and values set according to the columns configuration.\r\n     *\r\n     * When the object does not need to be prepared, the original object is returned.\r\n     */\r\n    this.prepare = source => {\r\n        if (isSimple) {\r\n            return source; // a simple ColumnSet requires no object preparation;\r\n        }\r\n        var target = {};\r\n        $arr.forEach(this.columns, c => {\r\n            var a = colDesc(c, source);\r\n            if (c.init) {\r\n                target[a.name] = c.init.call(source, a);\r\n            } else {\r\n                if (a.exists || 'def' in c) {\r\n                    target[a.name] = a.value;\r\n                }\r\n            }\r\n        });\r\n        return target;\r\n    };\r\n\r\n    Object.freeze(this);\r\n\r\n    function colDesc(column, source) {\r\n        var a = {\r\n            source: source,\r\n            name: column.prop || column.name\r\n        };\r\n        a.exists = a.name in source;\r\n        if (a.exists) {\r\n            a.value = source[a.name];\r\n        } else {\r\n            a.value = 'def' in column ? column.def : undefined;\r\n        }\r\n        return a;\r\n    }\r\n}\r\n\r\n/**\r\n * @method helpers.ColumnSet.toString\r\n * @description\r\n * Creates a well-formatted multi-line string that represents the object.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * @param {number} [level=0]\r\n * Nested output level, to provide visual offset.\r\n *\r\n * @returns {string}\r\n */\r\nColumnSet.prototype.toString = function (level) {\r\n    level = level > 0 ? parseInt(level) : 0;\r\n    var gap0 = $npm.utils.messageGap(level),\r\n        gap1 = $npm.utils.messageGap(level + 1),\r\n        lines = [\r\n            'ColumnSet {'\r\n        ];\r\n    if (this.table) {\r\n        lines.push(gap1 + 'table: ' + this.table);\r\n    }\r\n    if (this.columns.length) {\r\n        lines.push(gap1 + 'columns: [');\r\n        $arr.forEach(this.columns, c => {\r\n            lines.push(c.toString(2));\r\n        });\r\n        lines.push(gap1 + ']');\r\n    } else {\r\n        lines.push(gap1 + 'columns: []');\r\n    }\r\n    lines.push(gap0 + '}');\r\n    return lines.join($npm.os.EOL);\r\n};\r\n\r\nColumnSet.prototype.inspect = function () {\r\n    return this.toString();\r\n};\r\n\r\nmodule.exports = ColumnSet;\r\n","/home/travis/build/npmtest/node-npmtest-pg-promise/node_modules/pg-promise/lib/helpers/column.js":"'use strict';\r\n\r\nvar $npm = {\r\n    os: require('os'),\r\n    utils: require('../utils'),\r\n    formatting: require('../formatting')\r\n};\r\n\r\n/**\r\n *\r\n * @class helpers.Column\r\n * @description\r\n *\r\n * It is a read-only structure that contains details for a single column, to be primarily used by {@link helpers.ColumnSet ColumnSet}.\r\n *\r\n * The class parses and validates all the details, and prepares them for high-performance query generation.\r\n *\r\n * @param {String|helpers.ColumnConfig} col\r\n * Column details, depending on the type.\r\n *\r\n * When it is a string, it is expected to contain a name for both the column and the source property, assuming that the two are the same.\r\n * The name must adhere to JavaScript syntax for variable names. The name can be appended with any format modifier as supported by\r\n * {@link formatting.format as.format} (`^`, `~`, `#`, `:csv`, `:json`, `:name`, `:raw`, `:value`), which is then removed from the name and put\r\n * into property `mod`. If the name starts with `?`, it is removed, while setting flag `cnd` = `true`.\r\n *\r\n * If the string doesn't adhere to the above requirements, the method will throw {@link external:TypeError TypeError} = `Invalid column syntax`.\r\n *\r\n * When `col` is a simple {@link helpers.ColumnConfig ColumnConfig}-like object, it is used as an input configurator to set all the properties\r\n * of the class.\r\n *\r\n * @property {string} name\r\n * Destination column name + source property name (if `prop` is skipped). The name must adhere to JavaScript syntax for variables,\r\n * unless `prop` is specified, in which case `name` represents only the column name, and therefore can be any string.\r\n *\r\n * @property {string} [prop]\r\n * Source property name, if different from the column's name. It must adhere to JavaScript syntax for variables.\r\n *\r\n * It is ignored when it is the same as `name`.\r\n *\r\n * @property {string} [mod]\r\n * Formatting modifier, as supported by method {@link formatting.format as.format}: `^`, `~`, `#`, `:csv`, `:json`, `:name`, `:raw`, `:value`.\r\n *\r\n * @property {string} [cast]\r\n * Server-side type casting, without `::` in front.\r\n *\r\n * @property {boolean} [cnd]\r\n * Conditional column flag.\r\n *\r\n * Used by methods {@link helpers.update update} and {@link helpers.sets sets}, ignored by methods {@link helpers.insert insert} and\r\n * {@link helpers.values values}. It indicates that the column is reserved for a `WHERE` condition, not to be set or updated.\r\n *\r\n * It can be set from a string initialization, by adding `?` in front of the name.\r\n *\r\n * @property {} [def]\r\n * Default value for the property, to be used only when the source object doesn't have the property.\r\n * It is ignored when property `init` is set.\r\n *\r\n * @property {helpers.initCB} [init]\r\n * Override callback for the value.\r\n *\r\n * @property {helpers.skipCB} [skip]\r\n * An override for skipping columns dynamically.\r\n *\r\n * Used by methods {@link helpers.update update} (for a single object) and {@link helpers.sets sets}, ignored by methods\r\n * {@link helpers.insert insert} and {@link helpers.values values}.\r\n *\r\n * It is also ignored when conditional flag `cnd` is set.\r\n *\r\n * @returns {helpers.Column}\r\n *\r\n * @see {@link helpers.ColumnConfig ColumnConfig}\r\n *\r\n * @example\r\n *\r\n * var pgp = require('pg-promise')({\r\n *     capSQL: true // if you want all generated SQL capitalized\r\n * });\r\n *\r\n * var Column = pgp.helpers.Column;\r\n *\r\n * // creating a column from just a name:\r\n * var col1 = new Column('colName');\r\n * console.log(col1);\r\n * //=>\r\n * // Column {\r\n * //    name: \"colName\"\r\n * // }\r\n *\r\n * // creating a column from a name + modifier:\r\n * var col2 = new Column('colName:csv');\r\n * console.log(col2);\r\n * //=>\r\n * // Column {\r\n * //    name: \"colName\"\r\n * //    mod: \":csv\"\r\n * // }\r\n *\r\n * // creating a column from a configurator:\r\n * var col3 = new Column({\r\n *     name: 'colName', // required\r\n *     prop: 'propName', // optional\r\n *     mod: '^', // optional\r\n *     def: 123 // optional\r\n * });\r\n * console.log(col3);\r\n * //=>\r\n * // Column {\r\n * //    name: \"colName\"\r\n * //    prop: \"propName\"\r\n * //    mod: \"^\"\r\n * //    def: 123\r\n * // }\r\n *\r\n */\r\nfunction Column(col) {\r\n\r\n    if (!(this instanceof Column)) {\r\n        return new Column(col);\r\n    }\r\n\r\n    if (typeof col === 'string') {\r\n        var info = parseColumn(col);\r\n        this.name = info.name;\r\n        if ('mod' in info) {\r\n            this.mod = info.mod;\r\n        }\r\n        if ('cnd' in info) {\r\n            this.cnd = info.cnd;\r\n        }\r\n    } else {\r\n        if (col && typeof col === 'object' && 'name' in col) {\r\n            if (!$npm.utils.isText(col.name)) {\r\n                throw new TypeError('Invalid \\'name\\' value: ' + JSON.stringify(col.name) + '. A non-empty string was expected.');\r\n            }\r\n            if ($npm.utils.isNull(col.prop) && !isValidVariable(col.name)) {\r\n                throw new TypeError('Invalid \\'name\\' syntax: ' + JSON.stringify(col.name) + '. A valid variable name was expected.');\r\n            }\r\n            this.name = col.name; // column name + property name (if 'prop' isn't specified)\r\n\r\n            if (!$npm.utils.isNull(col.prop)) {\r\n                if (!$npm.utils.isText(col.prop)) {\r\n                    throw new TypeError('Invalid \\'prop\\' value: ' + JSON.stringify(col.prop) + '. A non-empty string was expected.');\r\n                }\r\n                if (!isValidVariable(col.prop)) {\r\n                    throw new TypeError('Invalid \\'prop\\' syntax: ' + JSON.stringify(col.prop) + '. A valid variable name was expected.');\r\n                }\r\n                if (col.prop !== col.name) {\r\n                    // optional property name, if different from the column's name;\r\n                    this.prop = col.prop;\r\n                }\r\n            }\r\n            if (!$npm.utils.isNull(col.mod)) {\r\n                if (typeof col.mod !== 'string' || !isValidMod(col.mod)) {\r\n                    throw new TypeError('Invalid \\'mod\\' value: ' + JSON.stringify(col.mod) + '.');\r\n                }\r\n                this.mod = col.mod; // optional format modifier;\r\n            }\r\n            if (!$npm.utils.isNull(col.cast)) {\r\n                this.cast = parseCast(col.cast); // optional SQL type casting\r\n            }\r\n            if ('cnd' in col) {\r\n                this.cnd = !!col.cnd;\r\n            }\r\n            if ('def' in col) {\r\n                this.def = col.def; // optional default\r\n            }\r\n            if (typeof col.init === 'function') {\r\n                this.init = col.init; // optional value override (overrides 'def' also)\r\n            }\r\n            if (typeof col.skip === 'function') {\r\n                this.skip = col.skip;\r\n            }\r\n        } else {\r\n            throw new TypeError('Invalid column details.');\r\n        }\r\n    }\r\n\r\n    var variable = '${' + (this.prop || this.name) + (this.mod || '') + '}',\r\n        castText = this.cast ? ('::' + this.cast) : '',\r\n        escapedName = $npm.formatting.as.name(this.name);\r\n\r\n    Object.defineProperty(this, 'variable', {\r\n        enumerable: false,\r\n        value: variable\r\n    });\r\n\r\n    Object.defineProperty(this, 'castText', {\r\n        enumerable: false,\r\n        value: castText\r\n    });\r\n\r\n    Object.defineProperty(this, 'escapedName', {\r\n        enumerable: false,\r\n        value: escapedName\r\n    });\r\n\r\n    Object.freeze(this);\r\n}\r\n\r\nfunction parseCast(name) {\r\n    if (typeof name === 'string') {\r\n        var s = name.replace(/^[:\\s]*|\\s*$/g, '');\r\n        if (s) {\r\n            return s;\r\n        }\r\n    }\r\n    throw new TypeError('Invalid \\'cast\\' value: ' + JSON.stringify(name) + '.');\r\n}\r\n\r\nfunction parseColumn(name) {\r\n    var m = name.match(/\\??[a-zA-Z0-9\\$_]+(\\^|~|#|:raw|:name|:json|:csv|:value)?/);\r\n    if (m && m[0] === name) {\r\n        var res = {};\r\n        if (name[0] === '?') {\r\n            res.cnd = true;\r\n            name = name.substr(1);\r\n        }\r\n        var mod = name.match(/\\^|~|#|:raw|:name|:json|:csv|:value/);\r\n        if (mod) {\r\n            res.name = name.substr(0, mod.index);\r\n            res.mod = mod[0];\r\n        } else {\r\n            res.name = name;\r\n        }\r\n        return res;\r\n    }\r\n    throw new TypeError('Invalid column syntax: ' + JSON.stringify(name) + '.');\r\n}\r\n\r\nfunction isValidMod(mod) {\r\n    var values = ['^', '~', '#', ':raw', ':name', ':json', ':csv', ':value'];\r\n    return values.indexOf(mod) !== -1;\r\n}\r\n\r\nfunction isValidVariable(name) {\r\n    var m = name.match(/^[0-9]+|[a-zA-Z0-9\\$_]+/);\r\n    return !!m && m[0] === name;\r\n}\r\n\r\n/**\r\n * @method helpers.Column.toString\r\n * @description\r\n * Creates a well-formatted multi-line string that represents the object.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * @param {number} [level=0]\r\n * Nested output level, to provide visual offset.\r\n *\r\n * @returns {string}\r\n */\r\nColumn.prototype.toString = function (level) {\r\n    level = level > 0 ? parseInt(level) : 0;\r\n    var gap0 = $npm.utils.messageGap(level),\r\n        gap1 = $npm.utils.messageGap(level + 1),\r\n        lines = [\r\n            gap0 + 'Column {',\r\n            gap1 + 'name: ' + JSON.stringify(this.name)\r\n        ];\r\n    if ('prop' in this) {\r\n        lines.push(gap1 + 'prop: ' + JSON.stringify(this.prop));\r\n    }\r\n    if ('mod' in this) {\r\n        lines.push(gap1 + 'mod: ' + JSON.stringify(this.mod));\r\n    }\r\n    if ('cast' in this) {\r\n        lines.push(gap1 + 'cast: ' + JSON.stringify(this.cast));\r\n    }\r\n    if ('cnd' in this) {\r\n        lines.push(gap1 + 'cnd: ' + JSON.stringify(this.cnd));\r\n    }\r\n    if ('def' in this) {\r\n        lines.push(gap1 + 'def: ' + JSON.stringify(this.def));\r\n    }\r\n    if ('init' in this) {\r\n        lines.push(gap1 + 'init: [Function]');\r\n    }\r\n    if ('skip' in this) {\r\n        lines.push(gap1 + 'skip: [Function]');\r\n    }\r\n    lines.push(gap0 + '}');\r\n    return lines.join($npm.os.EOL);\r\n};\r\n\r\nColumn.prototype.inspect = function () {\r\n    return this.toString();\r\n};\r\n\r\n/**\r\n * @typedef helpers.ColumnConfig\r\n * @description\r\n * A simple structure with column details, to be passed into the {@link helpers.Column Column} constructor for initialization.\r\n *\r\n * @property {string} name\r\n * Destination column name + source property name (if `prop` is skipped). The name must adhere to JavaScript syntax for variables,\r\n * unless `prop` is specified, in which case `name` represents only the column name, and therefore can be any string.\r\n *\r\n * @property {string} [prop]\r\n * Source property name, if different from the column's name. It must adhere to JavaScript syntax for variables.\r\n *\r\n * It is ignored when it is the same as `name`.\r\n *\r\n * @property {string} [mod]\r\n * Formatting modifier, as supported by method {@link formatting.format as.format}: `^`, `~`, `#`, `:csv`, `:json`, `:name`, `:raw`, `:value`.\r\n *\r\n * @property {string} [cast]\r\n * Server-side type casting. Leading `::` is allowed, but not needed (automatically removed when specified).\r\n *\r\n * @property {boolean} [cnd]\r\n * Conditional column flag.\r\n *\r\n * Used by methods {@link helpers.update update} and {@link helpers.sets sets}, ignored by methods {@link helpers.insert insert} and\r\n * {@link helpers.values values}. It indicates that the column is reserved for a `WHERE` condition, not to be set or updated.\r\n *\r\n * It can be set from a string initialization, by adding `?` in front of the name.\r\n *\r\n * @property {} [def]\r\n * Default value for the property, to be used only when the source object doesn't have the property.\r\n * It is ignored when property `init` is set.\r\n *\r\n * @property {helpers.initCB} [init]\r\n * Override callback for the value.\r\n *\r\n * @property {helpers.skipCB} [skip]\r\n * An override for skipping columns dynamically.\r\n *\r\n * Used by methods {@link helpers.update update} (for a single object) and {@link helpers.sets sets}, ignored by methods\r\n * {@link helpers.insert insert} and {@link helpers.values values}.\r\n *\r\n * It is also ignored when conditional flag `cnd` is set.\r\n *\r\n */\r\n\r\n/**\r\n * @callback helpers.initCB\r\n * @description\r\n * A callback function type used by parameter `init` within {@link helpers.ColumnConfig ColumnConfig}.\r\n *\r\n * It works as an override for the corresponding property value in the `source` object.\r\n *\r\n * The function is called with `this` set to the `source` object.\r\n *\r\n * @param {} col\r\n * Column-to-property descriptor.\r\n *\r\n * @param {object} col.source\r\n * The source object, equals to `this` that's passed into the function.\r\n *\r\n * @param {string} col.name\r\n * Name of the property within the `source` object.\r\n *\r\n * @param {} col.value\r\n *\r\n * Property value, set to one of the following:\r\n *\r\n * - Value of the property within the `source` object (`value` = `source[name]`), if the property exists\r\n * - If the property doesn't exist and `def` is set in the column, then `value` is set to the value of `def`\r\n * - If the property doesn't exist and `def` is not set in the column, then `value` is set to `undefined`\r\n *\r\n * @param {boolean} col.exists\r\n * Indicates whether the property exists in the `source` object (`exists = name in source`).\r\n *\r\n * @returns {}\r\n * The new value to be used for the corresponding column.\r\n */\r\n\r\n/**\r\n * @callback helpers.skipCB\r\n * @description\r\n * A callback function type used by parameter `skip` within {@link helpers.ColumnConfig ColumnConfig}.\r\n *\r\n * It is to dynamically determine when the property with specified `name` in the `source` object is to be skipped.\r\n *\r\n * The function is called with `this` set to the `source` object.\r\n *\r\n * @param {} col\r\n * Column-to-property descriptor.\r\n *\r\n * @param {object} col.source\r\n * The source object, equals to `this` that's passed into the function.\r\n *\r\n * @param {string} col.name\r\n * Name of the property within the `source` object.\r\n *\r\n * @param {} col.value\r\n *\r\n * Property value, set to one of the following:\r\n *\r\n * - Value of the property within the `source` object (`value` = `source[name]`), if the property exists\r\n * - If the property doesn't exist and `def` is set in the column, then `value` is set to the value of `def`\r\n * - If the property doesn't exist and `def` is not set in the column, then `value` is set to `undefined`\r\n *\r\n * @param {boolean} col.exists\r\n * Indicates whether the property exists in the `source` object (`exists = name in source`).\r\n *\r\n * @returns {boolean}\r\n * A truthy value that indicates whether the column is to be skipped.\r\n *\r\n */\r\n\r\nmodule.exports = Column;\r\n","/home/travis/build/npmtest/node-npmtest-pg-promise/node_modules/pg-promise/lib/helpers/methods/update.js":"'use strict';\r\n\r\nvar $npm = {\r\n    TableName: require('../tableName'),\r\n    ColumnSet: require('../columnSet'),\r\n    formatting: require('../../formatting'),\r\n    utils: require('../../utils')\r\n};\r\n\r\nvar $arr = require('../../array');\r\n\r\n/**\r\n * @method helpers.update\r\n * @description\r\n * Generates a simplified `UPDATE` query for either one object or an array of objects.\r\n *\r\n * The resulting query needs a `WHERE` clause to be appended to it, to determine the update logic.\r\n * This is to allow for update conditions of any complexity that are easy to add.\r\n *\r\n * @param {object|object[]} data\r\n * An update object with properties for update values, or an array of such objects.\r\n *\r\n * When `data` is not a non-null object and not an array, it will throw {@link external:TypeError TypeError} = `Invalid parameter 'data' specified.`\r\n *\r\n * When `data` is an empty array, it will throw {@link external:TypeError TypeError} = `Cannot generate an UPDATE from an empty array.`\r\n *\r\n * When `data` is an array that contains a non-object value, the method will throw {@link external:Error Error} =\r\n * `Invalid update object at index N.`\r\n *\r\n * @param {array|helpers.Column|helpers.ColumnSet} [columns]\r\n * Set of columns to be updated.\r\n *\r\n * It is optional when `data` is a single object, and required when `data` is an array of objects. If not specified for an array\r\n * of objects, the method will throw {@link external:TypeError TypeError} = `Parameter 'columns' is required when updating multiple records.`\r\n *\r\n * When `columns` is not a {@link helpers.ColumnSet ColumnSet} object, a temporary {@link helpers.ColumnSet ColumnSet}\r\n * is created - from the value of `columns` (if it was specified), or from the value of `data` (if it is not an array).\r\n *\r\n * When the final {@link helpers.ColumnSet ColumnSet} is empty (no columns in it), the method will throw\r\n * {@link external:Error Error} = `Cannot generate an UPDATE without any columns.`, unless option `emptyUpdate` was specified.\r\n *\r\n * @param {helpers.TableName|string|{table,schema}} [table]\r\n * Table to be updated.\r\n *\r\n * It is normally a required parameter. But when `columns` is passed in as a {@link helpers.ColumnSet ColumnSet} object\r\n * with `table` set in it, that will be used when this parameter isn't specified. When neither is available, the method\r\n * will throw {@link external:Error Error} = `Table name is unknown.`\r\n *\r\n * @param {object} [options]\r\n * An object with formatting options for multi-row `UPDATE` queries.\r\n *\r\n * @param {string} [options.tableAlias=t]\r\n * Name of the SQL variable that represents the destination table.\r\n *\r\n * @param {string} [options.valueAlias=v]\r\n * Name of the SQL variable that represents the values.\r\n *\r\n * @param {} [options.emptyUpdate]\r\n * **Added in v.5.6.7**\r\n *\r\n * This is a convenience option, to avoid throwing an error when generating a conditional update results in no columns.\r\n *\r\n * When present, regardless of the value, this option overrides the method's behaviour when applying `skip` logic results in no columns,\r\n * i.e. when every column is being skipped.\r\n *\r\n * By default, in that situation the method throws {@link external:Error Error} = `Cannot generate an UPDATE without any columns.`\r\n * But when this option is present, the method will instead return whatever value the option was passed.\r\n *\r\n * @returns {}\r\n * The method usually returns the resulting query string that typically needs a `WHERE` condition appended.\r\n *\r\n * However, if it results in an empty update, and option `emptyUpdate` was passed in, then the method returns whatever\r\n * value the option was passed.\r\n *\r\n * @see\r\n *  {@link helpers.Column Column},\r\n *  {@link helpers.ColumnSet ColumnSet},\r\n *  {@link helpers.TableName TableName}\r\n *\r\n * @example\r\n *\r\n * var pgp = require('pg-promise')({\r\n *    capSQL: true // if you want all generated SQL capitalized\r\n * });\r\n *\r\n * var dataSingle = {id: 1, val: 123, msg: 'hello'};\r\n * var dataMulti = [{id: 1, val: 123, msg: 'hello'}, {id: 2, val: 456, msg: 'world!'}];\r\n *\r\n * // Although column details can be taken from the data object, it is not\r\n * // a likely scenario for an update, unless updating the whole table:\r\n *\r\n * pgp.helpers.update(dataSingle, null, 'my-table');\r\n * //=> UPDATE \"my-table\" SET \"id\"=1,\"val\"=123,\"msg\"='hello'\r\n *\r\n * @example\r\n *\r\n * // A typical single-object update:\r\n *\r\n * pgp.helpers.update(dataSingle, ['val', 'msg'], 'my-table') + ' WHERE id = ' + dataSingle.id;\r\n * //=> UPDATE \"my-table\" SET \"val\"=123,\"msg\"='hello' WHERE id = 1\r\n *\r\n * @example\r\n *\r\n * // Column details are required for a multi-row `UPDATE`;\r\n * // Adding '?' in front of a column name means it is only for a WHERE condition:\r\n *\r\n * pgp.helpers.update(dataMulti, ['?id', 'val', 'msg'], 'my-table') + ' WHERE v.id = t.id';\r\n * //=> UPDATE \"my-table\" AS t SET \"val\"=v.\"val\",\"msg\"=v.\"msg\" FROM (VALUES(1,123,'hello'),(2,456,'world!'))\r\n * //   AS v(\"id\",\"val\",\"msg\") WHERE v.id = t.id\r\n *\r\n * @example\r\n *\r\n * // Column details from a reusable ColumnSet (recommended for performance):\r\n *\r\n * var cs = new pgp.helpers.ColumnSet(['?id', 'val', 'msg'], {table: 'my-table'});\r\n *\r\n * pgp.helpers.update(dataMulti, cs) + ' WHERE v.id = t.id';\r\n * //=> UPDATE \"my-table\" AS t SET \"val\"=v.\"val\",\"msg\"=v.\"msg\" FROM (VALUES(1,123,'hello'),(2,456,'world!'))\r\n * //   AS v(\"id\",\"val\",\"msg\") WHERE v.id = t.id\r\n *\r\n * @example\r\n *\r\n * // Using parameter `options` to change the default alias names:\r\n *\r\n * pgp.helpers.update(dataMulti, cs, null, {tableAlias: 'X', valueAlias: 'Y'}) + ' WHERE Y.id = X.id';\r\n * //=> UPDATE \"my-table\" AS X SET \"val\"=Y.\"val\",\"msg\"=Y.\"msg\" FROM (VALUES(1,123,'hello'),(2,456,'world!'))\r\n * //   AS Y(\"id\",\"val\",\"msg\") WHERE Y.id = X.id\r\n *\r\n * @example\r\n *\r\n * // Handling an empty update\r\n *\r\n * var cs = new pgp.helpers.ColumnSet(['?id', '?name'], {table: 'tt'}); // no actual update-able columns\r\n * var result = pgp.helpers.update(dataMulti, cs, null, {emptyUpdate: 123});\r\n * if(result === 123) {\r\n *    // We know the update is empty, i.e. no columns that can be updated;\r\n *    // And it didn't throw because we specified `emptyUpdate` option.\r\n * }\r\n */\r\nfunction update(data, columns, table, options, capSQL) {\r\n\r\n    if (!data || typeof data !== 'object') {\r\n        throw new TypeError('Invalid parameter \\'data\\' specified.');\r\n    }\r\n\r\n    var isArray = Array.isArray(data);\r\n\r\n    if (isArray && !data.length) {\r\n        throw new TypeError('Cannot generate an UPDATE from an empty array.');\r\n    }\r\n\r\n    if (columns instanceof $npm.ColumnSet) {\r\n        if ($npm.utils.isNull(table)) {\r\n            table = columns.table;\r\n        }\r\n    } else {\r\n        if (isArray && $npm.utils.isNull(columns)) {\r\n            throw new TypeError('Parameter \\'columns\\' is required when updating multiple records.');\r\n        }\r\n        columns = new $npm.ColumnSet(columns || data);\r\n    }\r\n\r\n    options = options || {};\r\n\r\n    var format = $npm.formatting.as.format,\r\n        useEmptyUpdate = 'emptyUpdate' in options;\r\n\r\n    if (isArray) {\r\n        var tableAlias = 't', valueAlias = 'v';\r\n        if ($npm.utils.isText(options.tableAlias)) {\r\n            tableAlias = options.tableAlias;\r\n        }\r\n        if ($npm.utils.isText(options.valueAlias)) {\r\n            valueAlias = options.valueAlias;\r\n        }\r\n\r\n        var q = capSQL ? sql.multi.capCase : sql.multi.lowCase;\r\n\r\n        var actualColumns = $arr.filter(columns.columns, c => !c.cnd);\r\n\r\n        if (checkColumns(actualColumns)) {\r\n            return options.emptyUpdate;\r\n        }\r\n\r\n        checkTable();\r\n\r\n        var targetCols = $arr.map(actualColumns, c => c.escapedName + '=' + valueAlias + '.' + c.escapedName).join();\r\n\r\n        var values = $arr.map(data, (d, index) => {\r\n            if (!d || typeof d !== 'object') {\r\n                throw new Error('Invalid update object at index ' + index + '.');\r\n            }\r\n            return '(' + format(columns.variables, columns.prepare(d)) + ')';\r\n        }).join();\r\n\r\n        return format(q, [table.name, tableAlias, targetCols, values, valueAlias, columns.names]);\r\n    }\r\n\r\n    var updates = columns.assign(data);\r\n\r\n    if (checkColumns(updates)) {\r\n        return options.emptyUpdate;\r\n    }\r\n\r\n    checkTable();\r\n\r\n    var query = capSQL ? sql.single.capCase : sql.single.lowCase;\r\n\r\n    return format(query, table.name) + format(updates, columns.prepare(data));\r\n\r\n    function checkTable() {\r\n        if (table && !(table instanceof $npm.TableName)) {\r\n            table = new $npm.TableName(table);\r\n        }\r\n        if (!table) {\r\n            throw new Error('Table name is unknown.');\r\n        }\r\n    }\r\n\r\n    function checkColumns(cols) {\r\n        if (!cols.length) {\r\n            if (useEmptyUpdate) {\r\n                return true;\r\n            }\r\n            throw new Error('Cannot generate an UPDATE without any columns.');\r\n        }\r\n    }\r\n}\r\n\r\nvar sql = {\r\n    single: {\r\n        lowCase: 'update $1^ set ',\r\n        capCase: 'UPDATE $1^ SET '\r\n    },\r\n    multi: {\r\n        lowCase: 'update $1^ as $2^ set $3^ from (values$4^) as $5^($6^)',\r\n        capCase: 'UPDATE $1^ AS $2^ SET $3^ FROM (VALUES$4^) AS $5^($6^)'\r\n    }\r\n};\r\n\r\nmodule.exports = update;\r\n","/home/travis/build/npmtest/node-npmtest-pg-promise/node_modules/pg-promise/lib/helpers/methods/values.js":"'use strict';\r\n\r\nvar $npm = {\r\n    ColumnSet: require('../columnSet'),\r\n    formatting: require('../../formatting'),\r\n    utils: require('../../utils')\r\n};\r\n\r\nvar $arr = require('../../array');\r\n\r\n/**\r\n * @method helpers.values\r\n * @description\r\n * Generates a string of comma-separated value groups from either one object or an array of objects,\r\n * to be used as part of a query:\r\n *\r\n * - from a single object: `(val_1, val_2, ...)`\r\n * - from an array of objects: `(val_11, val_12, ...), (val_21, val_22, ...)`\r\n *\r\n * @param {object|object[]} data\r\n * A source object with properties as values, or an array of such objects.\r\n *\r\n * If it is anything else, the method will throw {@link external:TypeError TypeError} = `Invalid parameter 'data' specified.`\r\n *\r\n * When `data` is an array that contains a non-object value, the method will throw {@link external:Error Error} =\r\n * `Invalid object at index N.`\r\n *\r\n * When `data` is an empty array, an empty string is returned.\r\n *\r\n * @param {array|helpers.Column|helpers.ColumnSet} [columns]\r\n * Columns for which to return values.\r\n *\r\n * It is optional when `data` is a single object, and required when `data` is an array of objects. If not specified for an array\r\n * of objects, the method will throw {@link external:TypeError TypeError} = `Parameter 'columns' is required when generating multi-row values.`\r\n *\r\n * When the final {@link helpers.ColumnSet ColumnSet} is empty (no columns in it), the method will throw\r\n * {@link external:Error Error} = `Cannot generate values without any columns.`\r\n *\r\n * @returns {string}\r\n * - comma-separated value groups, according to `data`\r\n * - an empty string, if `data` is an empty array\r\n *\r\n * @see\r\n *  {@link helpers.Column Column},\r\n *  {@link helpers.ColumnSet ColumnSet}\r\n *\r\n * @example\r\n *\r\n * var pgp = require('pg-promise')();\r\n *\r\n * var dataSingle = {val: 123, msg: 'hello'};\r\n * var dataMulti = [{val: 123, msg: 'hello'}, {val: 456, msg: 'world!'}];\r\n *\r\n * // Properties can be pulled automatically from a single object:\r\n *\r\n * pgp.helpers.values(dataSingle);\r\n * //=> (123,'hello')\r\n *\r\n * @example\r\n *\r\n * // Column details are required when using an array of objects:\r\n *\r\n * pgp.helpers.values(dataMulti, ['val', 'msg']);\r\n * //=> (123,'hello'),(456,'world!')\r\n *\r\n * @example\r\n *\r\n * // Column details from a reusable ColumnSet (recommended for performance):\r\n *\r\n * var cs = new pgp.helpers.ColumnSet(['val', 'msg']);\r\n *\r\n * pgp.helpers.values(dataMulti, cs);\r\n * //=> (123,'hello'),(456,'world!')\r\n *\r\n */\r\nfunction values(data, columns) {\r\n\r\n    if (!data || typeof data !== 'object') {\r\n        throw new TypeError('Invalid parameter \\'data\\' specified.');\r\n    }\r\n\r\n    var isArray = Array.isArray(data);\r\n\r\n    if (!(columns instanceof $npm.ColumnSet)) {\r\n        if (isArray && $npm.utils.isNull(columns)) {\r\n            throw new TypeError('Parameter \\'columns\\' is required when generating multi-row values.');\r\n        }\r\n        columns = new $npm.ColumnSet(columns || data);\r\n    }\r\n\r\n    if (!columns.columns.length) {\r\n        throw new Error('Cannot generate values without any columns.');\r\n    }\r\n\r\n    var format = $npm.formatting.as.format;\r\n\r\n    if (isArray) {\r\n        return $arr.map(data, (d, index) => {\r\n            if (!d || typeof d !== 'object') {\r\n                throw new Error('Invalid object at index ' + index + '.');\r\n            }\r\n            return '(' + format(columns.variables, columns.prepare(d)) + ')';\r\n        }).join();\r\n    }\r\n    return '(' + format(columns.variables, columns.prepare(data)) + ')';\r\n}\r\n\r\nmodule.exports = values;\r\n","/home/travis/build/npmtest/node-npmtest-pg-promise/node_modules/pg-promise/lib/helpers/methods/sets.js":"'use strict';\r\n\r\nvar $npm = {\r\n    ColumnSet: require('../columnSet'),\r\n    format: require('../../formatting').as.format,\r\n    utils: require('../../utils')\r\n};\r\n\r\n/**\r\n * @method helpers.sets\r\n * @description\r\n * Generates a string of comma-separated value-set statements from a single object: `col1=val1, col2=val2, ...`,\r\n * to be used as part of a query.\r\n *\r\n * Since it is to be used as part of `UPDATE` queries, {@link helpers.Column Column} properties `cnd` and `skip` apply.\r\n *\r\n * @param {object} data\r\n * A simple, non-null and non-array source object.\r\n *\r\n * If it is anything else, the method will throw {@link external:TypeError TypeError} = `Invalid parameter 'data' specified.`\r\n *\r\n * @param {array|helpers.Column|helpers.ColumnSet} [columns]\r\n * Columns for which to set values.\r\n *\r\n * When not specified, properties of the `data` object are used.\r\n *\r\n * When no effective columns are found, an empty string is returned.\r\n *\r\n * @returns {string}\r\n * - comma-separated value-set statements for the `data` object\r\n * - an empty string, if no effective columns found\r\n *\r\n * @see\r\n *  {@link helpers.Column Column},\r\n *  {@link helpers.ColumnSet ColumnSet}\r\n *\r\n * @example\r\n *\r\n * var pgp = require('pg-promise')();\r\n *\r\n * var data = {id: 1, val: 123, msg: 'hello'};\r\n *\r\n * // Properties can be pulled automatically from the object:\r\n *\r\n * pgp.helpers.sets(data);\r\n * //=> \"id\"=1,\"val\"=123,\"msg\"='hello'\r\n *\r\n * @example\r\n *\r\n * // Column details from a reusable ColumnSet (recommended for performance);\r\n * // NOTE: Conditional columns (start with '?') are skipped:\r\n *\r\n * var cs = new pgp.helpers.ColumnSet(['?id','val', 'msg']);\r\n *\r\n * pgp.helpers.sets(data, cs);\r\n * //=> \"val\"=123,\"msg\"='hello'\r\n *\r\n */\r\nfunction sets(data, columns) {\r\n\r\n    if (!data || typeof data !== 'object' || Array.isArray(data)) {\r\n        throw new TypeError('Invalid parameter \\'data\\' specified.');\r\n    }\r\n\r\n    if (!(columns instanceof $npm.ColumnSet)) {\r\n        columns = new $npm.ColumnSet(columns || data);\r\n    }\r\n\r\n    return $npm.format(columns.assign(data), columns.prepare(data));\r\n}\r\n\r\nmodule.exports = sets;\r\n","/home/travis/build/npmtest/node-npmtest-pg-promise/node_modules/pg-promise/lib/errors/index.js":"'use strict';\r\n\r\nvar $npm = {\r\n    qResult: require('./queryResult'),\r\n    qFile: require('./queryFile'),\r\n    prepared: require('./prepared'),\r\n    paramQuery: require('./paramQuery')\r\n};\r\n\r\n/**\r\n * @namespace errors\r\n * @description\r\n * Error types namespace, available as `pgp.errors`, before and after initializing the library.\r\n *\r\n * @property {function} PreparedStatementError\r\n * {@link errors.PreparedStatementError PreparedStatementError} class constructor.\r\n *\r\n * Represents all errors that can be reported by class {@link PreparedStatement}.\r\n *\r\n * @property {function} ParameterizedQueryError\r\n * {@link errors.ParameterizedQueryError ParameterizedQueryError} class constructor.\r\n *\r\n * Represents all errors that can be reported by class {@link ParameterizedQuery}.\r\n *\r\n * @property {function} QueryFileError\r\n * {@link errors.QueryFileError QueryFileError} class constructor.\r\n *\r\n * Represents all errors that can be reported by class {@link QueryFile}.\r\n *\r\n * @property {function} QueryResultError\r\n * {@link errors.QueryResultError QueryResultError} class constructor.\r\n *\r\n * Represents all result-specific errors from query methods.\r\n *\r\n * @property {errors.queryResultErrorCode} queryResultErrorCode\r\n * Error codes `enum` used by class {@link errors.QueryResultError QueryResultError}.\r\n *\r\n */\r\n\r\nmodule.exports = {\r\n    QueryResultError: $npm.qResult.QueryResultError,\r\n    queryResultErrorCode: $npm.qResult.queryResultErrorCode,\r\n    PreparedStatementError: $npm.prepared,\r\n    ParameterizedQueryError: $npm.paramQuery,\r\n    QueryFileError: $npm.qFile\r\n};\r\n\r\nObject.freeze(module.exports);\r\n","/home/travis/build/npmtest/node-npmtest-pg-promise/node_modules/pg-promise/lib/errors/queryResult.js":"'use strict';\r\n\r\nvar $npm = {\r\n    os: require('os'),\r\n    utils: require('../utils')\r\n};\r\n\r\n/**\r\n * @enum {number}\r\n * @alias errors.queryResultErrorCode\r\n * @readonly\r\n * @description\r\n * `queryResultErrorCode` enumerator, available from the {@link errors} namespace.\r\n *\r\n * Represents an integer code for each type of error supported by type {@link errors.QueryResultError}.\r\n *\r\n * @see {@link errors.QueryResultError}\r\n */\r\nvar queryResultErrorCode = {\r\n    /** No data returned from the query. */\r\n    noData: 0,\r\n\r\n    /** No return data was expected. */\r\n    notEmpty: 1,\r\n\r\n    /** Multiple rows were not expected. */\r\n    multiple: 2\r\n};\r\n\r\nObject.freeze(queryResultErrorCode);\r\n\r\nvar errorMessages = [\r\n    {name: 'noData', message: 'No data returned from the query.'},\r\n    {name: 'notEmpty', message: 'No return data was expected.'},\r\n    {name: 'multiple', message: 'Multiple rows were not expected.'}\r\n];\r\n\r\n/**\r\n * @interface errors.QueryResultError\r\n * @augments external:Error\r\n * @description\r\n *\r\n * This error is specified as the rejection reason for all result-specific methods when the result doesn't match\r\n * the expectation, i.e. when a query result doesn't match its Query Result Mask - the value of {@link queryResult}.\r\n *\r\n * The error applies to the result from the following methods: {@link Database.none none},\r\n * {@link Database.one one}, {@link Database.oneOrNone oneOrNone} and {@link Database.many many}.\r\n *\r\n * Supported errors:\r\n *\r\n * - `No return data was expected.`, method {@link Database.none none}\r\n * - `No data returned from the query.`, methods {@link Database.one one} and {@link Database.many many}\r\n * - `Multiple rows were not expected.`, methods {@link Database.one one} and {@link Database.oneOrNone oneOrNone}\r\n *\r\n * Like any other error, this one is notified with through the global event {@link event:error error}.\r\n *\r\n * The type is available from the {@link errors} namespace.\r\n *\r\n * @property {string} name\r\n * Standard {@link external:Error Error} property - error type name = `QueryResultError`.\r\n *\r\n * @property {string} message\r\n * Standard {@link external:Error Error} property - the error message.\r\n *\r\n * @property {string} stack\r\n * Standard {@link external:Error Error} property - the stack trace.\r\n *\r\n * @property {object} result\r\n * The original $[Result] object that was received.\r\n *\r\n * @property {number} received\r\n * Total number of rows received. It is simply the value of `result.rows.length`.\r\n *\r\n * @property {number} code\r\n * Error code - {@link errors.queryResultErrorCode queryResultErrorCode} value.\r\n *\r\n * @property {string} query\r\n * Query that was executed.\r\n *\r\n * Normally, it is the query already formatted with values, if there were any.\r\n * But if you are using initialization option `pgFormatting`, then the query string is before formatting.\r\n *\r\n * @property {} values\r\n * Values passed in as query parameters. Available only when initialization option `pgFormatting` is used.\r\n * Otherwise, the values are within the pre-formatted `query` string.\r\n *\r\n * @example\r\n *\r\n * var QueryResultError = pgp.errors.QueryResultError;\r\n * var qrec = pgp.errors.queryResultErrorCode;\r\n *\r\n * var options = {\r\n *\r\n *   // pg-promise initialization options...\r\n *\r\n *   error: (err, e) => {\r\n *       if (err instanceof QueryResultError) {\r\n *           // A query returned unexpected number of records, and thus rejected;\r\n *           \r\n *           // we can check the error code, if we want specifics:\r\n *           if(err.code === qrec.noData) {\r\n *               // expected some data, but received none;\r\n *           }\r\n *\r\n *           // If you write QueryResultError into the console,\r\n *           // you will get a nicely formatted output.\r\n *\r\n *           console.log(err);\r\n *           \r\n *           // See also: err, e.query, e.params, etc.\r\n *       }\r\n *   }\r\n * };\r\n *\r\n * @see\r\n * {@link queryResult}, {@link Database.none none}, {@link Database.one one},\r\n * {@link Database.oneOrNone oneOrNone}, {@link Database.many many}\r\n *\r\n */\r\nfunction QueryResultError(code, result, query, values) {\r\n    var temp = Error.apply(this, arguments);\r\n    temp.name = this.name = 'QueryResultError';\r\n    this.stack = temp.stack;\r\n    this.message = errorMessages[code].message;\r\n    this.code = code;\r\n    this.result = result;\r\n    this.query = query;\r\n    this.values = values;\r\n    this.received = result.rows.length;\r\n}\r\n\r\nQueryResultError.prototype = Object.create(Error.prototype, {\r\n    constructor: {\r\n        value: QueryResultError,\r\n        writable: true,\r\n        configurable: true\r\n    }\r\n});\r\n\r\n/**\r\n * @method errors.QueryResultError.toString\r\n * @description\r\n * Creates a well-formatted multi-line string that represents the error.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * @param {number} [level=0]\r\n * Nested output level, to provide visual offset.\r\n *\r\n * @returns {string}\r\n */\r\nQueryResultError.prototype.toString = function (level) {\r\n    level = level > 0 ? parseInt(level) : 0;\r\n    var gap0 = $npm.utils.messageGap(level),\r\n        gap1 = $npm.utils.messageGap(level + 1),\r\n        lines = [\r\n            'QueryResultError {',\r\n            gap1 + 'code: queryResultErrorCode.' + errorMessages[this.code].name,\r\n            gap1 + 'message: \"' + this.message + '\"',\r\n            gap1 + 'received: ' + this.received,\r\n            gap1 + 'query: ' + (typeof this.query === 'string' ? '\"' + this.query + '\"' : JSON.stringify(this.query))\r\n        ];\r\n    if (this.values !== undefined) {\r\n        lines.push(gap1 + 'values: ' + JSON.stringify(this.values));\r\n    }\r\n    lines.push(gap0 + '}');\r\n    return lines.join($npm.os.EOL);\r\n};\r\n\r\nQueryResultError.prototype.inspect = function () {\r\n    return this.toString();\r\n};\r\n\r\nmodule.exports = {\r\n    QueryResultError: QueryResultError,\r\n    queryResultErrorCode: queryResultErrorCode\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-pg-promise/node_modules/pg-promise/lib/errors/prepared.js":"'use strict';\r\n\r\nvar $npm = {\r\n    os: require('os'),\r\n    utils: require('../utils'),\r\n    QueryFileError: require('./queryFile')\r\n};\r\n\r\n/**\r\n * @interface errors.PreparedStatementError\r\n * @augments external:Error\r\n * @description\r\n * {@link errors.PreparedStatementError PreparedStatementError} interface, available from the {@link errors} namespace.\r\n *\r\n * This type represents all errors that can be reported by class {@link PreparedStatement}, whether it is used\r\n * explicitly or implicitly (via a simple `{name, text, values}` object).\r\n *\r\n * @property {string} name\r\n * Standard {@link external:Error Error} property - error type name = `PreparedStatementError`.\r\n *\r\n * @property {string} message\r\n * Standard {@link external:Error Error} property - the error message.\r\n *\r\n * @property {string} stack\r\n * Standard {@link external:Error Error} property - the stack trace.\r\n *\r\n * @property {errors.QueryFileError} error\r\n * Internal {@link errors.QueryFileError} object.\r\n *\r\n * It is set only when the source {@link PreparedStatement} used a {@link QueryFile} which threw the error.\r\n *\r\n * @property {object} result\r\n * Resulting Prepared Statement object.\r\n *\r\n * @see PreparedStatement\r\n */\r\nfunction PreparedStatementError(error, ps) {\r\n    var temp = Error.apply(this, arguments);\r\n    temp.name = this.name = 'PreparedStatementError';\r\n    this.stack = temp.stack;\r\n    if (error instanceof $npm.QueryFileError) {\r\n        this.error = error;\r\n        this.message = 'Failed to initialize \\'text\\' from a QueryFile.';\r\n    } else {\r\n        this.message = error;\r\n    }\r\n    this.result = ps;\r\n}\r\n\r\nPreparedStatementError.prototype = Object.create(Error.prototype, {\r\n    constructor: {\r\n        value: PreparedStatementError,\r\n        writable: true,\r\n        configurable: true\r\n    }\r\n});\r\n\r\n/**\r\n * @method errors.PreparedStatementError.toString\r\n * @description\r\n * Creates a well-formatted multi-line string that represents the error.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * @param {number} [level=0]\r\n * Nested output level, to provide visual offset.\r\n *\r\n * @returns {string}\r\n */\r\nPreparedStatementError.prototype.toString = function (level) {\r\n    level = level > 0 ? parseInt(level) : 0;\r\n    var gap0 = $npm.utils.messageGap(level),\r\n        gap1 = $npm.utils.messageGap(level + 1),\r\n        gap2 = $npm.utils.messageGap(level + 2),\r\n        lines = [\r\n            'PreparedStatementError {',\r\n            gap1 + 'message: \"' + this.message + '\"',\r\n            gap1 + 'result: {',\r\n            gap2 + 'name: ' + JSON.stringify(this.result.name),\r\n            gap2 + 'text: ' + JSON.stringify(this.result.text),\r\n            gap2 + 'values: ' + JSON.stringify(this.result.values),\r\n            gap1 + '}'\r\n        ];\r\n    if (this.error) {\r\n        lines.push(gap1 + 'error: ' + this.error.toString(level + 1));\r\n    }\r\n    lines.push(gap0 + '}');\r\n    return lines.join($npm.os.EOL);\r\n};\r\n\r\nPreparedStatementError.prototype.inspect = function () {\r\n    return this.toString();\r\n};\r\n\r\nmodule.exports = PreparedStatementError;\r\n","/home/travis/build/npmtest/node-npmtest-pg-promise/node_modules/pg-promise/lib/errors/paramQuery.js":"'use strict';\r\n\r\nvar $npm = {\r\n    os: require('os'),\r\n    utils: require('../utils'),\r\n    QueryFileError: require('./queryFile')\r\n};\r\n\r\n/**\r\n * @interface errors.ParameterizedQueryError\r\n * @augments external:Error\r\n * @description\r\n * {@link errors.ParameterizedQueryError ParameterizedQueryError} interface, available from the {@link errors} namespace.\r\n *\r\n * This type represents all errors that can be reported by class {@link ParameterizedQuery}, whether it is used\r\n * explicitly or implicitly (via a simple `{text, values}` object).\r\n *\r\n * @property {string} name\r\n * Standard {@link external:Error Error} property - error type name = `ParameterizedQueryError`.\r\n *\r\n * @property {string} message\r\n * Standard {@link external:Error Error} property - the error message.\r\n *\r\n * @property {string} stack\r\n * Standard {@link external:Error Error} property - the stack trace.\r\n *\r\n * @property {errors.QueryFileError} error\r\n * Internal {@link errors.QueryFileError} object.\r\n *\r\n * It is set only when the source {@link ParameterizedQuery} used a {@link QueryFile} which threw the error.\r\n *\r\n * @property {object} result\r\n * Resulting Parameterized Query object.\r\n *\r\n * @see ParameterizedQuery\r\n */\r\nfunction ParameterizedQueryError(error, ps) {\r\n    var temp = Error.apply(this, arguments);\r\n    temp.name = this.name = 'ParameterizedQueryError';\r\n    this.stack = temp.stack;\r\n    if (error instanceof $npm.QueryFileError) {\r\n        this.error = error;\r\n        this.message = 'Failed to initialize \\'text\\' from a QueryFile.';\r\n    } else {\r\n        this.message = error;\r\n    }\r\n    this.result = ps;\r\n}\r\n\r\nParameterizedQueryError.prototype = Object.create(Error.prototype, {\r\n    constructor: {\r\n        value: ParameterizedQueryError,\r\n        writable: true,\r\n        configurable: true\r\n    }\r\n});\r\n\r\n/**\r\n * @method errors.ParameterizedQueryError.toString\r\n * @description\r\n * Creates a well-formatted multi-line string that represents the error.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * @param {number} [level=0]\r\n * Nested output level, to provide visual offset.\r\n *\r\n * @returns {string}\r\n */\r\nParameterizedQueryError.prototype.toString = function (level) {\r\n    level = level > 0 ? parseInt(level) : 0;\r\n    var gap0 = $npm.utils.messageGap(level),\r\n        gap1 = $npm.utils.messageGap(level + 1),\r\n        gap2 = $npm.utils.messageGap(level + 2),\r\n        lines = [\r\n            'ParameterizedQueryError {',\r\n            gap1 + 'message: \"' + this.message + '\"',\r\n            gap1 + 'result: {',\r\n            gap2 + 'text: ' + JSON.stringify(this.result.text),\r\n            gap2 + 'values: ' + JSON.stringify(this.result.values),\r\n            gap1 + '}'\r\n        ];\r\n    if (this.error) {\r\n        lines.push(gap1 + 'error: ' + this.error.toString(level + 1));\r\n    }\r\n    lines.push(gap0 + '}');\r\n    return lines.join($npm.os.EOL);\r\n};\r\n\r\nParameterizedQueryError.prototype.inspect = function () {\r\n    return this.toString();\r\n};\r\n\r\nmodule.exports = ParameterizedQueryError;\r\n","/home/travis/build/npmtest/node-npmtest-pg-promise/node_modules/pg-promise/lib/utils/public.js":"'use strict';\r\n\r\nvar $npm = {\r\n    fs: require('fs'),\r\n    path: require('path'),\r\n    utils: require('./'),\r\n    package: require('../../package.json')\r\n};\r\n\r\nvar EOL = require('os').EOL;\r\n\r\n/**\r\n * @method utils.camelize\r\n * @description\r\n * Camelizes a text string.\r\n *\r\n * Case-changing characters include:\r\n * - _hyphen_\r\n * - _underscore_\r\n * - _period_\r\n * - _space_\r\n *\r\n * @param {string} text\r\n * Input text string.\r\n *\r\n * @returns {string}\r\n * Camelized text string.\r\n *\r\n * @see\r\n * {@link utils.camelizeVar camelizeVar}\r\n *\r\n */\r\nfunction camelize(text) {\r\n    text = text.replace(/[\\-_\\s\\.]+(.)?/g, (match, chr) => {\r\n        return chr ? chr.toUpperCase() : '';\r\n    });\r\n    return text.substr(0, 1).toLowerCase() + text.substr(1);\r\n}\r\n\r\n/**\r\n * @method utils.camelizeVar\r\n * @description\r\n * Camelizes a text string, while making it compliant with JavaScript variable names:\r\n * - contains symbols `a-z`, `A-Z`, `0-9`, `_` and `$`\r\n * - cannot have leading digits\r\n *\r\n * First, it removes all symbols that do not meet the above criteria, except for _hyphen_, _period_ and _space_,\r\n * and then it forwards into {@link utils.camelize camelize}.\r\n *\r\n * @param {string} text\r\n * Input text string.\r\n *\r\n * If it doesn't contain any symbols to make up a valid variable name, the result will be an empty string.\r\n *\r\n * @returns {string}\r\n * Camelized text string that can be used as an open property name.\r\n *\r\n * @see\r\n * {@link utils.camelize camelize}\r\n *\r\n */\r\nfunction camelizeVar(text) {\r\n    text = text.replace(/[^a-zA-Z0-9\\$_\\-\\s\\.]/g, '').replace(/^[0-9_\\-\\s\\.]+/, '');\r\n    return camelize(text);\r\n}\r\n\r\nfunction _enumSql(dir, options, cb, namePath) {\r\n    var tree = {};\r\n    $npm.fs.readdirSync(dir).forEach(file => {\r\n        var stat, fullPath = $npm.path.join(dir, file);\r\n        try {\r\n            stat = $npm.fs.statSync(fullPath);\r\n        } catch (e) {\r\n            // while it is very easy to test manually, it is very difficult to test for\r\n            // access-denied errors automatically; therefore excluding from the coverage:\r\n            // istanbul ignore next\r\n            if (options.ignoreErrors) {\r\n                return; // on to the next file/folder;\r\n            }\r\n            // istanbul ignore next\r\n            throw e;\r\n        }\r\n        if (stat.isDirectory()) {\r\n            if (options.recursive) {\r\n                var dirName = camelizeVar(file);\r\n                var np = namePath ? (namePath + '.' + dirName) : dirName;\r\n                var t = _enumSql(fullPath, options, cb, np);\r\n                if (Object.keys(t).length) {\r\n                    if (!dirName.length || dirName in tree) {\r\n                        if (!options.ignoreErrors) {\r\n                            throw new Error('Empty or duplicate camelized folder name: ' + fullPath);\r\n                        }\r\n                    }\r\n                    tree[dirName] = t;\r\n                }\r\n            }\r\n        } else {\r\n            if ($npm.path.extname(file).toLowerCase() === '.sql') {\r\n                var name = camelizeVar(file.replace(/\\.[^/.]+$/, ''));\r\n                if (!name.length || name in tree) {\r\n                    if (!options.ignoreErrors) {\r\n                        throw new Error('Empty or duplicate camelized file name: ' + fullPath);\r\n                    }\r\n                }\r\n                tree[name] = fullPath;\r\n                if (cb) {\r\n                    var result = cb(fullPath, name, namePath ? (namePath + '.' + name) : name);\r\n                    if (result !== undefined) {\r\n                        tree[name] = result;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    });\r\n    return tree;\r\n}\r\n\r\n/**\r\n * @method utils.enumSql\r\n * @description\r\n * Synchronously enumerates all SQL files (within a given directory) into a camelized SQL tree.\r\n *\r\n * All property names within the tree are camelized via {@link utils.camelizeVar camelizeVar},\r\n * so they can be used in the code directly, as open property names.\r\n *\r\n * @param {string} dir\r\n * Directory path where SQL files are located, either absolute or relative to the current directory.\r\n *\r\n * SQL files are identified by using `.sql` extension (case-insensitive).\r\n *\r\n * @param {object} [options]\r\n * Search options.\r\n *\r\n * @param {boolean} [options.recursive=false]\r\n * Include sub-directories into the search.\r\n *\r\n * Sub-directories without SQL files will be skipped from the result.\r\n *\r\n * @param {boolean} [options.ignoreErrors=false]\r\n * Ignore the following types of errors:\r\n * - access errors, when there is no read access to a file or folder\r\n * - empty or duplicate camelized property names\r\n *\r\n * This flag does not affect errors related to invalid input parameters, or if you pass in a\r\n * non-existing directory.\r\n *\r\n * @param {function} [cb]\r\n * A callback function that takes three arguments:\r\n * - `file` - SQL file path, relative or absolute, according to how you specified the search directory\r\n * - `name` - name of the property that represents the SQL file\r\n * - `path` - property resolution path (full property name)\r\n *\r\n * If the function returns anything other than `undefined`, it overrides the corresponding property value in the tree.\r\n *\r\n * @returns {object}\r\n * Camelized SQL tree object, with each value being an SQL file path (unless changed via the callback).\r\n *\r\n * @see\r\n * {@link utils.objectToCode objectToCode},\r\n * {@link utils.buildSqlModule buildSqlModule}\r\n *\r\n * @example\r\n *\r\n * // simple SQL tree generation for further processing:\r\n * var tree = pgp.utils.enumSql('../sql', {recursive: true});\r\n *\r\n * @example\r\n *\r\n * // generating an SQL tree for dynamic use of names:\r\n * var sql = pgp.utils.enumSql(__dirname, {recursive: true}, file=> {\r\n *     return new pgp.QueryFile(file, {minify: true});\r\n * });\r\n *\r\n * @example\r\n *\r\n * var path = require('path');\r\n *\r\n * // replacing each relative path in the tree with a full one:\r\n * var tree = pgp.utils.enumSql('../sql', {recursive: true}, file=> {\r\n *     return path.join(__dirname, file);\r\n * });\r\n *\r\n */\r\nfunction enumSql(dir, options, cb) {\r\n    if (!$npm.utils.isText(dir)) {\r\n        throw new TypeError('Parameter \\'dir\\' must be a non-empty text string.');\r\n    }\r\n    if (!options || typeof options !== 'object') {\r\n        options = {};\r\n    }\r\n    cb = (typeof cb === 'function') ? cb : null;\r\n    return _enumSql(dir, options, cb, '');\r\n}\r\n\r\n/**\r\n *\r\n * @method utils.objectToCode\r\n * @description\r\n * Translates an object tree into a well-formatted JSON code string.\r\n *\r\n * @param {object} obj\r\n * Source tree object.\r\n *\r\n * @param {function} [cb]\r\n * A callback function to override property values for the code.\r\n *\r\n * It takes three arguments:\r\n *\r\n * - `value` - property value\r\n * - `name` - property name\r\n * - `obj` - current object (which contains the property)\r\n *\r\n * The returned value is used as is for the property value in the generated code.\r\n *\r\n * @returns {string}\r\n *\r\n * @see\r\n * {@link utils.enumSql enumSql},\r\n * {@link utils.buildSqlModule buildSqlModule}\r\n *\r\n * @example\r\n *\r\n * // Generating code for a simple object\r\n *\r\n * var tree = {one: 1, two: {item: 'abc'}};\r\n *\r\n * var code = pgp.utils.objectToCode(tree);\r\n *\r\n * console.log(code);\r\n * //=>\r\n * // {\r\n * //     one: 1,\r\n * //     two: {\r\n * //         item: \"abc\"\r\n * //     }\r\n * // }\r\n *\r\n * @example\r\n *\r\n * // Generating a Node.js module with an SQL tree\r\n *\r\n * var fs = require('fs');\r\n * var EOL = require('os').EOL;\r\n *\r\n * // generating an SQL tree from the folder:\r\n * var tree = pgp.utils.enumSql('./sql', {recursive: true});\r\n *\r\n * // generating the module's code:\r\n * var code = \"var load = require('./loadSql');\" + EOL + EOL + \"module.exports = \" +\r\n *         pgp.utils.objectToCode(tree, value => {\r\n *             return 'load(' + JSON.stringify(value) + ')';\r\n *         }) + ';';\r\n *\r\n * // saving the module:\r\n * fs.writeFileSync('sql.js', code);\r\n *\r\n * @example\r\n *\r\n * // generated code example (file sql.js)\r\n *\r\n * var load = require('./loadSql');\r\n *\r\n * module.exports = {\r\n *     events: {\r\n *         add: load(\"../sql/events/add.sql\"),\r\n *         delete: load(\"../sql/events/delete.sql\"),\r\n *         find: load(\"../sql/events/find.sql\"),\r\n *         update: load(\"../sql/events/update.sql\")\r\n *     },\r\n *     products: {\r\n *         add: load(\"../sql/products/add.sql\"),\r\n *         delete: load(\"../sql/products/delete.sql\"),\r\n *         find: load(\"../sql/products/find.sql\"),\r\n *         update: load(\"../sql/products/update.sql\")\r\n *     },\r\n *     users: {\r\n *         add: load(\"../sql/users/add.sql\"),\r\n *         delete: load(\"../sql/users/delete.sql\"),\r\n *         find: load(\"../sql/users/find.sql\"),\r\n *         update: load(\"../sql/users/update.sql\")\r\n *     },\r\n *     create: load(\"../sql/create.sql\"),\r\n *     init: load(\"../sql/init.sql\"),\r\n *     drop: load(\"../sql/drop.sql\")\r\n *};\r\n *\r\n * @example\r\n *\r\n * // loadSql.js module example\r\n *\r\n * var QueryFile = require('pg-promise').QueryFile;\r\n *\r\n * module.exports = file => {\r\n *     return new QueryFile(file, {minify: true});\r\n * };\r\n *\r\n */\r\nfunction objectToCode(obj, cb) {\r\n\r\n    if (!obj || typeof obj !== 'object') {\r\n        throw new TypeError('Parameter \\'obj\\' must be a non-null object.');\r\n    }\r\n\r\n    cb = (typeof cb === 'function') ? cb : null;\r\n\r\n    return '{' + generate(obj, 1) + EOL + '}';\r\n\r\n    function generate(obj, level) {\r\n        var code = '', gap = $npm.utils.messageGap(level);\r\n        var idx = 0;\r\n        for (var prop in obj) {\r\n            var value = obj[prop];\r\n            if (idx) {\r\n                code += ',';\r\n            }\r\n            if (value && typeof value === 'object') {\r\n                code += EOL + gap + prop + ': {';\r\n                code += generate(value, level + 1);\r\n                code += EOL + gap + '}';\r\n            } else {\r\n                code += EOL + gap + prop + ': ';\r\n                if (cb) {\r\n                    code += cb(value, prop, obj);\r\n                } else {\r\n                    code += JSON.stringify(value);\r\n                }\r\n            }\r\n            idx++;\r\n        }\r\n        return code;\r\n    }\r\n}\r\n\r\n/**\r\n * @method utils.buildSqlModule\r\n * @description\r\n * Synchronously generates a Node.js module with a camelized SQL tree, based on a configuration object that has the format shown below.\r\n *\r\n * This method is normally to be used on a grunt/gulp watch that triggers when the file structure changes in your SQL directory,\r\n * although it can be invoked manually as well.\r\n *\r\n * ```js\r\n * {\r\n *    // Required Properties:\r\n *    \r\n *    \"dir\" // {string}: relative or absolute directory where SQL files are located (see API for method enumSql, parameter `dir`)\r\n *\r\n *    // Optional Properties:\r\n *    \r\n *    \"recursive\" // {boolean}: search for sql files recursively (see API for method enumSql, option `recursive`)\r\n *\r\n *    \"ignoreErrors\" // {boolean}: ignore common errors (see API for method enumSql, option `ignoreErrors`)\r\n *\r\n *    \"output\" // {string}: relative or absolute destination file path; when not specified, no file is created,\r\n *             // but you still can use the code string that's always returned by the method.\r\n *     \r\n *    \"module\": {\r\n *        \"path\" // {string}: relative path to a module exporting a function which takes a file path\r\n *               // and returns a proper value (typically, a new QueryFile object); by default, it uses `./loadSql`.\r\n *\r\n *        \"name\" // {string}: local variable name for the SQL-loading module; by default, it uses `load`.\r\n *    }\r\n * }\r\n * ```\r\n *\r\n * @param {object|string} [config]\r\n * Configuration parameter for generating the code.\r\n *\r\n * - When it is a non-null object, it is assumed to be a configuration object (see the format above).\r\n * - When it is a text string - it is the relative path to either a JSON file that contains the configuration object,\r\n *   or a Node.js module that exports one. The path is relative to the application's entry point file.\r\n * - When `config` isn't specified, the method will try to locate the default `sql-config.json` file in the directory of your\r\n *   application's entry point file, and if not found - throw {@link external:Error Error} = `Default SQL configuration file not found`.\r\n *\r\n * @returns {string}\r\n * Generated code.\r\n *\r\n * @see\r\n * {@link utils.enumSql enumSql},\r\n * {@link utils.objectToCode objectToCode}\r\n *\r\n * @example\r\n *\r\n * // generate SQL module automatically, from sql-config.json in the module's start-up folder:\r\n *\r\n * pgp.utils.buildSqlModule();\r\n *\r\n * // see generated file below:\r\n *\r\n * @example\r\n *\r\n * /////////////////////////////////////////////////////////////////////////\r\n * // This file was automatically generated by pg-promise v.4.3.8\r\n * //\r\n * // Generated on: 6/2/2016, at 2:15:23 PM\r\n * // Total files: 15\r\n * //\r\n * // API: http://vitaly-t.github.io/pg-promise/utils.html#.buildSqlModule\r\n * /////////////////////////////////////////////////////////////////////////\r\n *\r\n * var load = require('./loadSql');\r\n *\r\n * module.exports = {\r\n *     events: {\r\n *         add: load(\"../sql/events/add.sql\"),\r\n *         delete: load(\"../sql/events/delete.sql\"),\r\n *         find: load(\"../sql/events/find.sql\"),\r\n *         update: load(\"../sql/events/update.sql\")\r\n *     },\r\n *     products: {\r\n *         add: load(\"../sql/products/add.sql\"),\r\n *         delete: load(\"../sql/products/delete.sql\"),\r\n *         find: load(\"../sql/products/find.sql\"),\r\n *         update: load(\"../sql/products/update.sql\")\r\n *     },\r\n *     users: {\r\n *         add: load(\"../sql/users/add.sql\"),\r\n *         delete: load(\"../sql/users/delete.sql\"),\r\n *         find: load(\"../sql/users/find.sql\"),\r\n *         update: load(\"../sql/users/update.sql\")\r\n *     },\r\n *     create: load(\"../sql/create.sql\"),\r\n *     init: load(\"../sql/init.sql\"),\r\n *     drop: load(\"../sql/drop.sql\")\r\n *};\r\n *\r\n */\r\nfunction buildSqlModule(config) {\r\n\r\n    if ($npm.utils.isText(config)) {\r\n        var path = $npm.utils.isPathAbsolute(config) ? config : $npm.path.join($npm.utils.startDir, config);\r\n        config = require(path);\r\n    } else {\r\n        if ($npm.utils.isNull(config)) {\r\n            var defConfig = $npm.path.join($npm.utils.startDir, 'sql-config.json');\r\n            // istanbul ignore else;\r\n            if (!$npm.fs.existsSync(defConfig)) {\r\n                throw new Error('Default SQL configuration file not found: ' + defConfig);\r\n            }\r\n            // cannot test this automatically, because it requires that file 'sql-config.json'\r\n            // resides within the Jasmine folder, since it is the client during the test.\r\n            // istanbul ignore next;\r\n            config = require(defConfig);\r\n        } else {\r\n            if (!config || typeof config !== 'object') {\r\n                throw new TypeError('Invalid parameter \\'config\\' specified.');\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!$npm.utils.isText(config.dir)) {\r\n        throw new Error('Property \\'dir\\' must be a non-empty string.');\r\n    }\r\n\r\n    var total = 0;\r\n\r\n    var tree = enumSql(config.dir, {recursive: config.recursive, ignoreErrors: config.ignoreErrors}, () => {\r\n        total++;\r\n    });\r\n\r\n    var modulePath = './loadSql', moduleName = 'load';\r\n    if (config.module && typeof config.module === 'object') {\r\n        if ($npm.utils.isText(config.module.path)) {\r\n            modulePath = config.module.path;\r\n        }\r\n        if ($npm.utils.isText(config.module.name)) {\r\n            moduleName = config.module.name;\r\n        }\r\n    }\r\n\r\n    var d = new Date();\r\n\r\n    var header =\r\n        '/////////////////////////////////////////////////////////////////////////' + EOL +\r\n        '// This file was automatically generated by pg-promise v.' + $npm.package.version + EOL +\r\n        '//' + EOL +\r\n        '// Generated on: ' + d.toLocaleDateString() + ', at ' + d.toLocaleTimeString() + EOL +\r\n        '// Total files: ' + total + EOL +\r\n        '//' + EOL +\r\n        '// API: http://vitaly-t.github.io/pg-promise/utils.html#.buildSqlModule' + EOL +\r\n        '/////////////////////////////////////////////////////////////////////////' + EOL + EOL +\r\n        '\\'use strict\\';' + EOL + EOL +\r\n        'var ' + moduleName + ' = require(\\'' + modulePath + '\\');' + EOL + EOL +\r\n        'module.exports = ';\r\n\r\n    var code = header + objectToCode(tree, value => {\r\n            return moduleName + '(' + JSON.stringify(value) + ')';\r\n        }) + ';';\r\n\r\n    if ($npm.utils.isText(config.output)) {\r\n        var p = config.output;\r\n        if (!$npm.utils.isPathAbsolute(p)) {\r\n            p = $npm.path.join($npm.utils.startDir, p);\r\n        }\r\n        $npm.fs.writeFileSync(p, code);\r\n    }\r\n\r\n    return code;\r\n}\r\n\r\n\r\n/**\r\n * @namespace utils\r\n *\r\n * @description\r\n * Namespace for general-purpose static functions, available as `pgp.utils`, before and after initializing the library.\r\n *\r\n * Its main purpose is to simplify developing projects with either large or dynamic number of SQL files.\r\n *\r\n * See also:\r\n * - [Automatic SQL Trees](https://github.com/vitaly-t/pg-promise/issues/153)\r\n * - [SQL Files](https://github.com/vitaly-t/pg-promise/wiki/SQL-Files)\r\n *\r\n * @property {function} camelize\r\n * {@link utils.camelize camelize} - camelizes a text string\r\n *\r\n * @property {function} camelizeVar\r\n * {@link utils.camelizeVar camelizeVar} - camelizes a text string as a variable\r\n *\r\n * @property {function} enumSql\r\n * {@link utils.enumSql enumSql} - enumerates SQL files in a directory\r\n *\r\n * @property {function} objectToCode\r\n * {@link utils.objectToCode objectToCode} - generates code from an object\r\n *\r\n * @property {function} buildSqlModule\r\n * {@link utils.buildSqlModule buildSqlModule} - generates a complete Node.js module\r\n *\r\n */\r\nmodule.exports = {\r\n    camelize: camelize,\r\n    camelizeVar: camelizeVar,\r\n    enumSql: enumSql,\r\n    objectToCode: objectToCode,\r\n    buildSqlModule: buildSqlModule\r\n};\r\n\r\nObject.freeze(module.exports);\r\n","/home/travis/build/npmtest/node-npmtest-pg-promise/node_modules/pg-promise/lib/txMode.js":"'use strict';\r\n\r\n/**\r\n * @enum {number}\r\n * @alias txMode.isolationLevel\r\n * @readonly\r\n * @summary Transaction Isolation Level.\r\n * @description\r\n * The type is available from the {@link txMode} namespace.\r\n *\r\n * @see $[Transaction Isolation]\r\n */\r\nvar isolationLevel = {\r\n    /** Isolation level not specified. */\r\n    none: 0,\r\n\r\n    /** ISOLATION LEVEL SERIALIZABLE */\r\n    serializable: 1,\r\n\r\n    /** ISOLATION LEVEL REPEATABLE READ */\r\n    repeatableRead: 2,\r\n\r\n    /** ISOLATION LEVEL READ COMMITTED */\r\n    readCommitted: 3\r\n\r\n    // From the official documentation: http://www.postgresql.org/docs/9.5/static/sql-set-transaction.html\r\n    // The SQL standard defines one additional level, READ UNCOMMITTED. In PostgreSQL READ UNCOMMITTED is treated as READ COMMITTED.\r\n    // => skipping `READ UNCOMMITTED`.\r\n};\r\n\r\nObject.freeze(isolationLevel);\r\n\r\n/**\r\n * @class txMode.TransactionMode\r\n * @description\r\n * **Alternative Syntax:** `TransactionMode({tiLevel, readOnly, deferrable})` &#8658; {@link TransactionMode}\r\n *\r\n * Constructs a complete transaction-opening command, based on the parameters:\r\n *  - isolation level\r\n *  - access mode\r\n *  - deferrable mode\r\n *\r\n * The type is available from the {@link txMode} namespace.\r\n *\r\n * @param {txMode.isolationLevel|Object} [tiLevel]\r\n * Transaction Isolation Level, or an object with parameters, if the alternative\r\n * syntax is used.\r\n *\r\n * @param {boolean} [readOnly]\r\n * Sets transaction access mode based on the read-only flag:\r\n *  - `undefined` - access mode not specified (default)\r\n *  - `true` - access mode is set to `READ ONLY`\r\n *  - `false` - access mode is set to `READ WRITE`\r\n *\r\n * @param {boolean} [deferrable]\r\n * Sets transaction deferrable mode based on the boolean value:\r\n *  - `undefined` - deferrable mode not specified (default)\r\n *  - `true` - mode is set to `DEFERRABLE`\r\n *  - `false` - mode is set to `NOT DEFERRABLE`\r\n *\r\n * It is used only when `tiLevel`=`isolationLevel.serializable`\r\n * and `readOnly`=`true`, or else it is ignored.\r\n *\r\n * @returns {txMode.TransactionMode}\r\n *\r\n * @see $[BEGIN], {@link txMode.isolationLevel}\r\n *\r\n * @example\r\n *\r\n * var TransactionMode = pgp.txMode.TransactionMode;\r\n * var isolationLevel = pgp.txMode.isolationLevel;\r\n *\r\n * // Create a reusable transaction mode (serializable + read-only + deferrable):\r\n * var tmSRD = new TransactionMode({\r\n *     tiLevel: isolationLevel.serializable,\r\n *     readOnly: true,\r\n *     deferrable: true\r\n * });\r\n *\r\n * function myTransaction() {\r\n *     return this.query(\"SELECT * FROM table\");\r\n * }\r\n *\r\n * myTransaction.txMode = tmSRD; // assign transaction mode;\r\n *\r\n * db.tx(myTransaction)\r\n *     .then(() => {\r\n *         // success;\r\n *     });\r\n *\r\n * // Instead of the default BEGIN, such transaction will initiate with:\r\n *\r\n * // BEGIN ISOLATION LEVEL SERIALIZABLE READ ONLY DEFERRABLE\r\n *\r\n */\r\nfunction TransactionMode(tiLevel, readOnly, deferrable) {\r\n\r\n    if (!(this instanceof TransactionMode)) {\r\n        return new TransactionMode(tiLevel, readOnly, deferrable);\r\n    }\r\n\r\n    if (tiLevel && typeof tiLevel === 'object') {\r\n        readOnly = tiLevel.readOnly;\r\n        deferrable = tiLevel.deferrable;\r\n        tiLevel = tiLevel.tiLevel;\r\n    }\r\n\r\n    var level, accessMode, deferrableMode, capBegin, begin = 'begin';\r\n\r\n    tiLevel = (tiLevel > 0) ? parseInt(tiLevel) : 0;\r\n\r\n    if (tiLevel > 0 && tiLevel < 4) {\r\n        var values = ['serializable', 'repeatable read', 'read committed'];\r\n        level = 'isolation level ' + values[tiLevel - 1];\r\n    }\r\n\r\n    if (readOnly) {\r\n        accessMode = 'read only';\r\n    } else {\r\n        if (readOnly !== undefined) {\r\n            accessMode = 'read write';\r\n        }\r\n    }\r\n\r\n    // From the official documentation: http://www.postgresql.org/docs/9.5/static/sql-set-transaction.html\r\n    // The DEFERRABLE transaction property has no effect unless the transaction is also SERIALIZABLE and READ ONLY\r\n    if (tiLevel === isolationLevel.serializable && readOnly) {\r\n        if (deferrable) {\r\n            deferrableMode = 'deferrable';\r\n        } else {\r\n            if (deferrable !== undefined) {\r\n                deferrableMode = 'not deferrable';\r\n            }\r\n        }\r\n    }\r\n\r\n    if (level) {\r\n        begin += ' ' + level;\r\n    }\r\n\r\n    if (accessMode) {\r\n        begin += ' ' + accessMode;\r\n    }\r\n\r\n    if (deferrableMode) {\r\n        begin += ' ' + deferrableMode;\r\n    }\r\n\r\n    capBegin = begin.toUpperCase();\r\n\r\n    this.begin = cap => {\r\n        return cap ? capBegin : begin;\r\n    };\r\n}\r\n\r\n/**\r\n * @namespace txMode\r\n * @description\r\n * Transaction Mode namespace, available as `pgp.txMode`, before and after initializing the library.\r\n *\r\n * Extends the default `BEGIN` with Transaction Mode parameters:\r\n *  - isolation level\r\n *  - access mode\r\n *  - deferrable mode\r\n *\r\n * @property {function} TransactionMode\r\n * {@link txMode.TransactionMode TransactionMode} class constructor.\r\n *\r\n * @property {txMode.isolationLevel} isolationLevel\r\n * Transaction Isolation Level enumerator\r\n *\r\n * @see $[BEGIN]\r\n */\r\nmodule.exports = {\r\n    isolationLevel: isolationLevel,\r\n    TransactionMode: TransactionMode\r\n};\r\n\r\nObject.freeze(module.exports);\r\n","/home/travis/build/npmtest/node-npmtest-pg-promise/node_modules/pg-promise/lib/types/index.js":"'use strict';\r\n\r\nvar $npm = {\r\n    utils: require('../utils'),\r\n    PS: require('./prepared'),\r\n    PQ: require('./parameterized')\r\n};\r\n\r\n// istanbul ignore next;\r\nfunction ExternalQuery() {\r\n}\r\n\r\nExternalQuery.prototype.inspect = function () {\r\n    return this.toString();\r\n};\r\n\r\n$npm.utils.inherits($npm.PS, ExternalQuery);\r\n$npm.utils.inherits($npm.PQ, ExternalQuery);\r\n\r\nmodule.exports = {\r\n    ExternalQuery: ExternalQuery,\r\n    PreparedStatement: $npm.PS,\r\n    ParameterizedQuery: $npm.PQ\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-pg-promise/node_modules/pg-promise/lib/types/prepared.js":"'use strict';\r\n\r\nvar $npm = {\r\n    os: require('os'),\r\n    utils: require('../utils'),\r\n    errors: require('../errors'),\r\n    QueryFile: require('../queryFile')\r\n};\r\n\r\n/**\r\n * @constructor PreparedStatement\r\n * @description\r\n * **Alternative Syntax:** `PreparedStatement({name, text, values, ...})` &#8658; {@link PreparedStatement}\r\n *\r\n * Constructs a new $[Prepared Statement] object.\r\n *\r\n * The alternative syntax supports advanced properties {@link PreparedStatement#binary binary}, {@link PreparedStatement#rowMode rowMode}\r\n * and {@link PreparedStatement#rows rows}, which are passed into $[pg], but not used by the class.\r\n *\r\n * All properties can also be set after the object's construction.\r\n *\r\n * This type extends the basic `{name, text, values}` object, by replacing it, i.e. when the basic object is used\r\n * with a query method, a new {@link PreparedStatement} object is created implicitly in its place.\r\n *\r\n * The type can be used in place of the `query` parameter, with any query method directly. And it never throws any error,\r\n * leaving it for query methods to reject with {@link errors.PreparedStatementError PreparedStatementError}.\r\n *\r\n * The type is available from the library's root: `pgp.PreparedStatement`.\r\n *\r\n * @param {string} name\r\n * An arbitrary name given to this particular prepared statement. It must be unique within a single session and is\r\n * subsequently used to execute or deallocate a previously prepared statement.\r\n *\r\n * @param {string|QueryFile} text\r\n * A non-empty query string or a {@link QueryFile} object.\r\n *\r\n * Only the basic variables (`$1`, `$2`, etc) can be used in the query, because $[Prepared Statements] are formatted by the database server.\r\n *\r\n * @param {array} [values]\r\n * Query formatting values. When it is not an `Array` and not `null`/`undefined`, it is automatically wrapped into an array.\r\n *\r\n * @returns {PreparedStatement}\r\n *\r\n * @see\r\n * {@link errors.PreparedStatementError PreparedStatementError},\r\n * {@link http://www.postgresql.org/docs/9.5/static/sql-prepare.html PostgreSQL Prepared Statements}\r\n *\r\n * @example\r\n *\r\n * var PS = require('pg-promise').PreparedStatement;\r\n *\r\n * // Creating a complete Prepared Statement with parameters:\r\n * var findUser = new PS('find-user', 'SELECT * FROM Users WHERE id = $1', [123]);\r\n *\r\n * db.one(findUser)\r\n *     .then(user=> {\r\n *         // user found;\r\n *     })\r\n *     .catch(error=> {\r\n *         // error;\r\n *     });\r\n *\r\n * @example\r\n *\r\n * var PS = require('pg-promise').PreparedStatement;\r\n *\r\n * // Creating a reusable Prepared Statement without values:\r\n * var addUser = new PS('add-user', 'INSERT INTO Users(name, age) VALUES($1, $2)');\r\n *\r\n * // setting values explicitly:\r\n * addUser.values = ['John', 30];\r\n *\r\n * db.none(addUser)\r\n *     .then(()=> {\r\n *         // user added;\r\n *     })\r\n *     .catch(error=> {\r\n *         // error;\r\n *     });\r\n *\r\n * // setting values implicitly, by passing them into the query method:\r\n * db.none(addUser, ['Mike', 25])\r\n *     .then(()=> {\r\n *         // user added;\r\n *     })\r\n *     .catch(error=> {\r\n *         // error;\r\n *     });\r\n */\r\nfunction PreparedStatement(name, text, values) {\r\n    if (!(this instanceof PreparedStatement)) {\r\n        return new PreparedStatement(name, text, values);\r\n    }\r\n\r\n    var currentError, PS = {}, changed = true, state = {\r\n        name: name,\r\n        text: text,\r\n        binary: undefined,\r\n        rowMode: undefined,\r\n        rows: undefined\r\n    };\r\n\r\n    function setValues(v) {\r\n        if (Array.isArray(v)) {\r\n            if (v.length) {\r\n                PS.values = v;\r\n            } else {\r\n                delete PS.values;\r\n            }\r\n        } else {\r\n            if ($npm.utils.isNull(v)) {\r\n                delete PS.values;\r\n            } else {\r\n                PS.values = [v];\r\n            }\r\n        }\r\n    }\r\n\r\n    setValues(values);\r\n\r\n    /**\r\n     * @name PreparedStatement#name\r\n     * @type {string}\r\n     * @description\r\n     * An arbitrary name given to this particular prepared statement. It must be unique within a single session and is\r\n     * subsequently used to execute or deallocate a previously prepared statement.\r\n     */\r\n    Object.defineProperty(this, 'name', {\r\n        get: () => state.name,\r\n        set: value => {\r\n            if (value !== state.name) {\r\n                state.name = value;\r\n                changed = true;\r\n            }\r\n        }\r\n    });\r\n\r\n    /**\r\n     * @name PreparedStatement#text\r\n     * @type {string|QueryFile}\r\n     * @description\r\n     * A non-empty query string or a {@link QueryFile} object.\r\n     *\r\n     * Changing this property for the same {@link PreparedStatement#name name} will have no effect, because queries\r\n     * for Prepared Statements are cached, with {@link PreparedStatement#name name} being the cache key.\r\n     */\r\n    Object.defineProperty(this, 'text', {\r\n        get: () => state.text,\r\n        set: value => {\r\n            if (value !== state.text) {\r\n                state.text = value;\r\n                changed = true;\r\n            }\r\n        }\r\n    });\r\n\r\n    /**\r\n     * @name PreparedStatement#values\r\n     * @type {array}\r\n     * @description\r\n     * Query formatting parameters, depending on the type:\r\n     *\r\n     * - `null` / `undefined` means the query has no formatting parameters\r\n     * - `Array` - it is an array of formatting parameters\r\n     * - None of the above, means it is a single formatting value, which\r\n     *   is then automatically wrapped into an array\r\n     */\r\n    Object.defineProperty(this, 'values', {\r\n        get: () => PS.values,\r\n        set: value => {\r\n            setValues(value);\r\n        }\r\n    });\r\n\r\n    /**\r\n     * @name PreparedStatement#binary\r\n     * @type {boolean}\r\n     * @default undefined\r\n     * @description\r\n     * Activates binary result mode. The default is the text mode.\r\n     *\r\n     * @see {@link http://www.postgresql.org/docs/devel/static/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY Extended Query}\r\n     */\r\n    Object.defineProperty(this, 'binary', {\r\n        get: () => state.binary,\r\n        set: value => {\r\n            if (value !== state.binary) {\r\n                state.binary = value;\r\n                changed = true;\r\n            }\r\n        }\r\n    });\r\n\r\n    /**\r\n     * @name PreparedStatement#rowMode\r\n     * @type {string}\r\n     * @default undefined\r\n     * @description\r\n     * Changes the way data arrives to the client, with only one value supported by $[pg]:\r\n     *  - `rowMode = 'array'` will make all data rows arrive as arrays of values.\r\n     *    By default, rows arrive as objects.\r\n     */\r\n    Object.defineProperty(this, 'rowMode', {\r\n        get: () => state.rowMode,\r\n        set: value => {\r\n            if (value !== state.rowMode) {\r\n                state.rowMode = value;\r\n                changed = true;\r\n            }\r\n        }\r\n    });\r\n\r\n    /**\r\n     * @name PreparedStatement#rows\r\n     * @type {number}\r\n     * @description\r\n     * Number of rows to return at a time from a Prepared Statement's portal.\r\n     * The default is 0, which means that all rows must be returned at once.\r\n     */\r\n    Object.defineProperty(this, 'rows', {\r\n        get: () => state.rows,\r\n        set: value => {\r\n            if (value !== state.rows) {\r\n                state.rows = value;\r\n                changed = true;\r\n            }\r\n        }\r\n    });\r\n\r\n    /**\r\n     * @name PreparedStatement#error\r\n     * @type {errors.PreparedStatementError}\r\n     * @default undefined\r\n     * @description\r\n     * When in an error state, it is set to a {@link errors.PreparedStatementError PreparedStatementError} object. Otherwise, it is `undefined`.\r\n     *\r\n     * This property is primarily for internal use by the library.\r\n     */\r\n    Object.defineProperty(this, 'error', {\r\n        get: () => currentError\r\n    });\r\n\r\n    if ($npm.utils.isObject(name, ['name'])) {\r\n        state.name = name.name;\r\n        state.text = name.text;\r\n        state.binary = name.binary;\r\n        state.rowMode = name.rowMode;\r\n        state.rows = name.rows;\r\n        setValues(name.values);\r\n    }\r\n\r\n    /**\r\n     * @method PreparedStatement.parse\r\n     * @description\r\n     * Parses the current object and returns a simple `{name, text, values}`, if successful,\r\n     * or else it returns a {@link errors.PreparedStatementError PreparedStatementError} object.\r\n     *\r\n     * This method is primarily for internal use by the library.\r\n     *\r\n     * @returns {{name, text, values}|errors.PreparedStatementError}\r\n     */\r\n    this.parse = () => {\r\n\r\n        var qf = state.text instanceof $npm.QueryFile ? state.text : null;\r\n\r\n        if (!changed && !qf) {\r\n            return PS;\r\n        }\r\n\r\n        var errors = [], values = PS.values;\r\n        PS = {\r\n            name: state.name\r\n        };\r\n        changed = true;\r\n        currentError = undefined;\r\n\r\n        if (!$npm.utils.isText(PS.name)) {\r\n            errors.push('Property \\'name\\' must be a non-empty text string.');\r\n        }\r\n\r\n        if (qf) {\r\n            qf.prepare();\r\n            if (qf.error) {\r\n                PS.text = state.text;\r\n                errors.push(qf.error);\r\n            } else {\r\n                PS.text = qf.query;\r\n            }\r\n        } else {\r\n            PS.text = state.text;\r\n        }\r\n        if (!$npm.utils.isText(PS.text)) {\r\n            errors.push('Property \\'text\\' must be a non-empty text string.');\r\n        }\r\n\r\n        if (!$npm.utils.isNull(values)) {\r\n            PS.values = values;\r\n        }\r\n\r\n        if (state.binary !== undefined) {\r\n            PS.binary = state.binary;\r\n        }\r\n\r\n        if (state.rowMode !== undefined) {\r\n            PS.rowMode = state.rowMode;\r\n        }\r\n\r\n        if (state.rows !== undefined) {\r\n            PS.rows = state.rows;\r\n        }\r\n\r\n        if (errors.length) {\r\n            return currentError = new $npm.errors.PreparedStatementError(errors[0], PS);\r\n        }\r\n\r\n        changed = false;\r\n\r\n        return PS;\r\n    };\r\n}\r\n\r\n/**\r\n * @method PreparedStatement.toString\r\n * @description\r\n * Creates a well-formatted multi-line string that represents the object's current state.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * @param {number} [level=0]\r\n * Nested output level, to provide visual offset.\r\n *\r\n * @returns {string}\r\n */\r\nPreparedStatement.prototype.toString = function (level) {\r\n    level = level > 0 ? parseInt(level) : 0;\r\n    var gap = $npm.utils.messageGap(level + 1);\r\n    var ps = this.parse();\r\n    var lines = [\r\n        'PreparedStatement {',\r\n        gap + 'name: ' + JSON.stringify(this.name)\r\n    ];\r\n    if ($npm.utils.isText(ps.text)) {\r\n        lines.push(gap + 'text: \"' + ps.text + '\"');\r\n    }\r\n    if (this.values !== undefined) {\r\n        lines.push(gap + 'values: ' + JSON.stringify(this.values));\r\n    }\r\n    if (this.binary !== undefined) {\r\n        lines.push(gap + 'binary: ' + JSON.stringify(this.binary));\r\n    }\r\n    if (this.rowMode !== undefined) {\r\n        lines.push(gap + 'rowMode: ' + JSON.stringify(this.rowMode));\r\n    }\r\n    if (this.rows !== undefined) {\r\n        lines.push(gap + 'rows: ' + JSON.stringify(this.rows));\r\n    }\r\n    if (this.error) {\r\n        lines.push(gap + 'error: ' + this.error.toString(level + 1));\r\n    }\r\n    lines.push($npm.utils.messageGap(level) + '}');\r\n    return lines.join($npm.os.EOL);\r\n};\r\n\r\nmodule.exports = PreparedStatement;\r\n\r\n","/home/travis/build/npmtest/node-npmtest-pg-promise/node_modules/pg-promise/lib/types/parameterized.js":"'use strict';\r\n\r\nvar $npm = {\r\n    os: require('os'),\r\n    utils: require('../utils'),\r\n    errors: require('../errors'),\r\n    QueryFile: require('../queryFile')\r\n};\r\n\r\n/**\r\n * @constructor ParameterizedQuery\r\n * @description\r\n * **Alternative Syntax:** `ParameterizedQuery({text, values, ...})` &#8658; {@link ParameterizedQuery}\r\n *\r\n * Constructs a new {@link ParameterizedQuery} object.\r\n *\r\n * The alternative syntax supports advanced properties {@link ParameterizedQuery#binary binary} and {@link ParameterizedQuery#rowMode rowMode},\r\n * which are passed into $[pg], but not used by the class.\r\n *\r\n * All properties can also be set after the object's construction.\r\n *\r\n * This type extends the basic `{text, values}` object, by replacing it, i.e. when the basic object is used\r\n * with a query method, a new {@link ParameterizedQuery} object is created implicitly in its place.\r\n *\r\n * The type can be used in place of the `query` parameter, with any query method directly. And it never throws any error,\r\n * leaving it for query methods to reject with {@link errors.ParameterizedQueryError ParameterizedQueryError}.\r\n *\r\n * The type is available from the library's root: `pgp.ParameterizedQuery`.\r\n *\r\n * @param {string|QueryFile} text\r\n * A non-empty query string or a {@link QueryFile} object.\r\n *\r\n * Only the basic variables (`$1`, `$2`, etc) can be used in the query, because _Parameterized Queries_ are formatted by the database server.\r\n *\r\n * @param {array} [values]\r\n * Query formatting values. When it is not an `Array` and not `null`/`undefined`, it is automatically wrapped into an array.\r\n *\r\n * @returns {ParameterizedQuery}\r\n *\r\n * @see\r\n * {@link errors.ParameterizedQueryError ParameterizedQueryError}\r\n *\r\n * @example\r\n *\r\n * var PQ = require('pg-promise').ParameterizedQuery;\r\n *\r\n * // Creating a complete Parameterized Query with parameters:\r\n * var findUser = new PQ('SELECT * FROM Users WHERE id = $1', [123]);\r\n *\r\n * db.one(findUser)\r\n *     .then(user=> {\r\n *         // user found;\r\n *     })\r\n *     .catch(error=> {\r\n *         // error;\r\n *     });\r\n *\r\n * @example\r\n *\r\n * var PQ = require('pg-promise').ParameterizedQuery;\r\n *\r\n * // Creating a reusable Parameterized Query without values:\r\n * var addUser = new PQ('INSERT INTO Users(name, age) VALUES($1, $2)');\r\n *\r\n * // setting values explicitly:\r\n * addUser.values = ['John', 30];\r\n *\r\n * db.none(addUser)\r\n *     .then(()=> {\r\n *         // user added;\r\n *     })\r\n *     .catch(error=> {\r\n *         // error;\r\n *     });\r\n *\r\n * // setting values implicitly, by passing them into the query method:\r\n * db.none(addUser, ['Mike', 25])\r\n *     .then(()=> {\r\n *         // user added;\r\n *     })\r\n *     .catch(error=> {\r\n *         // error;\r\n *     });\r\n *\r\n */\r\nfunction ParameterizedQuery(text, values) {\r\n    if (!(this instanceof ParameterizedQuery)) {\r\n        return new ParameterizedQuery(text, values);\r\n    }\r\n\r\n    var currentError, PQ = {}, changed = true, state = {\r\n        text: text,\r\n        binary: undefined,\r\n        rowMode: undefined\r\n    };\r\n\r\n    function setValues(v) {\r\n        if (Array.isArray(v)) {\r\n            if (v.length) {\r\n                PQ.values = v;\r\n            } else {\r\n                delete PQ.values;\r\n            }\r\n        } else {\r\n            if ($npm.utils.isNull(v)) {\r\n                delete PQ.values;\r\n            } else {\r\n                PQ.values = [v];\r\n            }\r\n        }\r\n    }\r\n\r\n    setValues(values);\r\n\r\n    /**\r\n     * @name ParameterizedQuery#text\r\n     * @type {string|QueryFile}\r\n     * @description\r\n     * A non-empty query string or a {@link QueryFile} object.\r\n     */\r\n    Object.defineProperty(this, 'text', {\r\n        get: () => state.text,\r\n        set: value => {\r\n            if (value !== state.text) {\r\n                state.text = value;\r\n                changed = true;\r\n            }\r\n        }\r\n    });\r\n\r\n    /**\r\n     * @name ParameterizedQuery#values\r\n     * @type {array}\r\n     * @description\r\n     * Query formatting parameters, depending on the type:\r\n     *\r\n     * - `null` / `undefined` means the query has no formatting parameters\r\n     * - `Array` - it is an array of formatting parameters\r\n     * - None of the above, means it is a single formatting value, which\r\n     *   is then automatically wrapped into an array\r\n     */\r\n    Object.defineProperty(this, 'values', {\r\n        get: () => PQ.values,\r\n        set: value => {\r\n            setValues(value);\r\n        }\r\n    });\r\n\r\n    /**\r\n     * @name ParameterizedQuery#binary\r\n     * @type {boolean}\r\n     * @default undefined\r\n     * @description\r\n     * Activates binary result mode. The default is the text mode.\r\n     *\r\n     * @see {@link http://www.postgresql.org/docs/devel/static/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY Extended Query}\r\n     */\r\n    Object.defineProperty(this, 'binary', {\r\n        get: () => state.binary,\r\n        set: value => {\r\n            if (value !== state.binary) {\r\n                state.binary = value;\r\n                changed = true;\r\n            }\r\n        }\r\n    });\r\n\r\n    /**\r\n     * @name ParameterizedQuery#rowMode\r\n     * @type {string}\r\n     * @default undefined\r\n     * @description\r\n     * Changes the way data arrives to the client, with only one value supported by $[pg]:\r\n     *  - `rowMode = 'array'` will make all data rows arrive as arrays of values.\r\n     *    By default, rows arrive as objects.\r\n     */\r\n    Object.defineProperty(this, 'rowMode', {\r\n        get: () => state.rowMode,\r\n        set: value => {\r\n            if (value !== state.rowMode) {\r\n                state.rowMode = value;\r\n                changed = true;\r\n            }\r\n        }\r\n    });\r\n\r\n    /**\r\n     * @name ParameterizedQuery#error\r\n     * @type {errors.ParameterizedQueryError}\r\n     * @default undefined\r\n     * @readonly\r\n     * @description\r\n     * When in an error state, it is set to a {@link errors.ParameterizedQueryError ParameterizedQueryError} object. Otherwise, it is `undefined`.\r\n     *\r\n     * This property is primarily for internal use by the library.\r\n     */\r\n    Object.defineProperty(this, 'error', {\r\n        get: () => currentError\r\n    });\r\n\r\n    if ($npm.utils.isObject(text, ['text'])) {\r\n        state.text = text.text;\r\n        state.binary = text.binary;\r\n        state.rowMode = text.rowMode;\r\n        setValues(text.values);\r\n    }\r\n\r\n    /**\r\n     * @method ParameterizedQuery.parse\r\n     * @description\r\n     * Parses the current object and returns a simple `{text, values}`, if successful,\r\n     * or else it returns a {@link errors.ParameterizedQueryError ParameterizedQueryError} object.\r\n     *\r\n     * This method is primarily for internal use by the library.\r\n     *\r\n     * @returns {{text, values}|errors.ParameterizedQueryError}\r\n     */\r\n    this.parse = () => {\r\n\r\n        var qf = state.text instanceof $npm.QueryFile ? state.text : null;\r\n\r\n        if (!changed && !qf) {\r\n            return PQ;\r\n        }\r\n\r\n        var errors = [], values = PQ.values;\r\n        PQ = {\r\n            name: state.name\r\n        };\r\n        changed = true;\r\n        currentError = undefined;\r\n\r\n        if (qf) {\r\n            qf.prepare();\r\n            if (qf.error) {\r\n                PQ.text = state.text;\r\n                errors.push(qf.error);\r\n            } else {\r\n                PQ.text = qf.query;\r\n            }\r\n        } else {\r\n            PQ.text = state.text;\r\n        }\r\n        if (!$npm.utils.isText(PQ.text)) {\r\n            errors.push('Property \\'text\\' must be a non-empty text string.');\r\n        }\r\n\r\n        if (!$npm.utils.isNull(values)) {\r\n            PQ.values = values;\r\n        }\r\n\r\n        if (state.binary !== undefined) {\r\n            PQ.binary = state.binary;\r\n        }\r\n\r\n        if (state.rowMode !== undefined) {\r\n            PQ.rowMode = state.rowMode;\r\n        }\r\n\r\n        if (errors.length) {\r\n            return currentError = new $npm.errors.ParameterizedQueryError(errors[0], PQ);\r\n        }\r\n\r\n        changed = false;\r\n\r\n        return PQ;\r\n    };\r\n}\r\n\r\n/**\r\n * @method ParameterizedQuery.toString\r\n * @description\r\n * Creates a well-formatted multi-line string that represents the object's current state.\r\n *\r\n * It is called automatically when writing the object into the console.\r\n *\r\n * @param {number} [level=0]\r\n * Nested output level, to provide visual offset.\r\n *\r\n * @returns {string}\r\n */\r\nParameterizedQuery.prototype.toString = function (level) {\r\n    level = level > 0 ? parseInt(level) : 0;\r\n    var gap = $npm.utils.messageGap(level + 1);\r\n    var pq = this.parse();\r\n    var lines = [\r\n        'ParameterizedQuery {'\r\n    ];\r\n    if ($npm.utils.isText(pq.text)) {\r\n        lines.push(gap + 'text: \"' + pq.text + '\"');\r\n    }\r\n    if (this.values !== undefined) {\r\n        lines.push(gap + 'values: ' + JSON.stringify(this.values));\r\n    }\r\n    if (this.binary !== undefined) {\r\n        lines.push(gap + 'binary: ' + JSON.stringify(this.binary));\r\n    }\r\n    if (this.rowMode !== undefined) {\r\n        lines.push(gap + 'rowMode: ' + JSON.stringify(this.rowMode));\r\n    }\r\n    if (this.error !== undefined) {\r\n        lines.push(gap + 'error: ' + this.error.toString(level + 1));\r\n    }\r\n    lines.push($npm.utils.messageGap(level) + '}');\r\n    return lines.join($npm.os.EOL);\r\n};\r\n\r\nmodule.exports = ParameterizedQuery;\r\n","/home/travis/build/npmtest/node-npmtest-pg-promise/node_modules/pg-promise/lib/async.js":"'use strict';\r\n\r\n/**\r\n * ES6 generators\r\n * @module async\r\n * @author Vitaly Tomilov\r\n * @private\r\n */\r\nmodule.exports = config => {\r\n\r\n    /////////////////////////////////\r\n    // Generator-to-Promise adapter;\r\n    //\r\n    // Based on: https://www.promisejs.org/generators/#both\r\n    return generator => {\r\n        var $p = config.promise;\r\n        return function () {\r\n            var g = generator.apply(this, arguments);\r\n\r\n            var handle = result => {\r\n                if (result.done) {\r\n                    return $p.resolve(result.value);\r\n                }\r\n                return $p.resolve(result.value)\r\n                    .then(data => handle(g.next(data)))\r\n                    .catch(err => handle(g.throw(err)));\r\n            };\r\n\r\n            return handle(g.next());\r\n        };\r\n    };\r\n\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-pg-promise/node_modules/pg-promise/lib/cnContext.js":"'use strict';\r\n\r\n/**\r\n * @constructor ConnectionContext\r\n * @private\r\n * @summary Connection context object.\r\n * @param {object} cn\r\n * @param {} dc\r\n * @param {object} options\r\n * @param {object} db\r\n * @param {number} txLevel\r\n */\r\nfunction ConnectionContext(cn, dc, options, db, txLevel) {\r\n\r\n    this.cn = cn; // connection details;\r\n    this.dc = dc; // database context;\r\n    this.options = options; // library options;\r\n    this.db = db; // database session;\r\n    this.txLevel = txLevel; // transaction level;\r\n\r\n    this.connect = function (db) {\r\n        this.db = db;\r\n    };\r\n\r\n    this.disconnect = function () {\r\n        if (this.db) {\r\n            this.db.done();\r\n            this.db = null;\r\n        }\r\n    };\r\n\r\n    this.clone = function () {\r\n        return new ConnectionContext(this.cn, this.dc, this.options, this.db, this.txLevel);\r\n    };\r\n}\r\n\r\n/**\r\n * Connection Context\r\n * @module context\r\n * @author Vitaly Tomilov\r\n * @private\r\n */\r\nmodule.exports = ConnectionContext;\r\n","/home/travis/build/npmtest/node-npmtest-pg-promise/node_modules/pg-promise/lib/connect.js":"'use strict';\r\n\r\nvar $npm = {\r\n    con: require('manakin').local,\r\n    utils: require('./utils'),\r\n    events: require('./events')\r\n};\r\n\r\nfunction poolConnect(ctx, config) {\r\n    return config.promise((resolve, reject) => {\r\n        config.pgp.pg.connect(ctx.cn, (err, client, done) => {\r\n            if (err) {\r\n                $npm.events.error(ctx.options, err, {\r\n                    cn: $npm.utils.getSafeConnection(ctx.cn),\r\n                    dc: ctx.dc\r\n                });\r\n                reject(err);\r\n            } else {\r\n                var isFresh = !client.$used;\r\n                if (isFresh) {\r\n                    $npm.utils.addReadProp(client, '$used', true, true);\r\n                }\r\n                setCtx(client, ctx);\r\n                var end = lockClientEnd(client);\r\n                resolve({\r\n                    isFresh: isFresh,\r\n                    client: client,\r\n                    done: () => {\r\n                        client.end = end;\r\n                        done();\r\n                        $npm.events.disconnect(ctx, client);\r\n                    }\r\n                });\r\n                $npm.events.connect(ctx, client, isFresh);\r\n            }\r\n        });\r\n    });\r\n}\r\n\r\nfunction directConnect(ctx, config) {\r\n    return config.promise((resolve, reject) => {\r\n        var client = new config.pgp.pg.Client(ctx.cn);\r\n        client.connect(err => {\r\n            if (err) {\r\n                $npm.events.error(ctx.options, err, {\r\n                    cn: $npm.utils.getSafeConnection(ctx.cn),\r\n                    dc: ctx.dc\r\n                });\r\n                reject(err);\r\n            } else {\r\n                setCtx(client, ctx);\r\n                var end = lockClientEnd(client);\r\n                resolve({\r\n                    isFresh: true,\r\n                    client: client,\r\n                    done: () => {\r\n                        client.end = end;\r\n                        client.end();\r\n                        $npm.events.disconnect(ctx, client);\r\n                    }\r\n                });\r\n                $npm.events.connect(ctx, client, true);\r\n            }\r\n        });\r\n    });\r\n}\r\n\r\nfunction lockClientEnd(client) {\r\n    var end = client.end;\r\n    client.end = () => {\r\n        // This call can happen only in the following two cases:\r\n        // 1. the client made the call directly, against the library's documentation (invalid code)\r\n        // 2. connection with the server broke while under heavy communications, and the connection\r\n        //    pool is trying to terminate all clients forcefully.\r\n        $npm.con.error('Abnormal client.end() call, due to invalid code or failed server connection.\\n%s\\n',\r\n            $npm.utils.getLocalStack(3));\r\n        end.call(client);\r\n    };\r\n    return end;\r\n}\r\n\r\nfunction setCtx(client, ctx) {\r\n    Object.defineProperty(client, '$ctx', {\r\n        value: ctx,\r\n        writable: true\r\n    });\r\n}\r\n\r\nmodule.exports = config => ({\r\n    pool: ctx => poolConnect(ctx, config),\r\n    direct: ctx => directConnect(ctx, config)\r\n});\r\n","/home/travis/build/npmtest/node-npmtest-pg-promise/node_modules/pg-promise/lib/events.js":"'use strict';\r\n\r\nvar $npm = {\r\n    con: require('manakin').local,\r\n    main: require('./'),\r\n    utils: require('./utils')\r\n};\r\n\r\n/////////////////////////////////\r\n// Client notification helpers;\r\nvar $events = {\r\n\r\n    /**\r\n     * @event connect\r\n     * @description\r\n     * Global notification of acquiring a new database connection from the connection pool,\r\n     * i.e. a virtual connection.\r\n     *\r\n     * However, for direct calls to method {@link Database.connect} with parameter `{direct: true}`,\r\n     * this event represents a physical connection.\r\n     *\r\n     * The library will suppress any error thrown by the handler and write it into the console.\r\n     *\r\n     * @param {external:Client} client\r\n     * $[pg.Client] object that represents the connection.\r\n     *\r\n     * @param {} dc\r\n     * Database Context that was used when creating the database object (see {@link Database}).\r\n     *\r\n     * @param {boolean} isFresh\r\n     * It indicates when it is a fresh physical connection:\r\n     * - `true` - the physical connection just has been allocated\r\n     * - `false` - the connection has been used previously\r\n     *\r\n     * **NOTE:**\r\n     *\r\n     * This parameter is always `true` for direct connections (created by calling {@link Database.connect}\r\n     * with parameter `{direct: true}`).\r\n     *\r\n     * @example\r\n     *\r\n     * var options = {\r\n     *\r\n     *     // pg-promise initialization options...\r\n     *\r\n     *     connect: (client, dc, isFresh) => {\r\n     *         var cp = client.connectionParameters;\r\n     *         console.log(\"Connected to database:\", cp.database);\r\n     *     }\r\n     *\r\n     * };\r\n     */\r\n    connect: (ctx, client, isFresh) => {\r\n        if (typeof ctx.options.connect === 'function') {\r\n            try {\r\n                ctx.options.connect(client, ctx.dc, isFresh);\r\n            } catch (e) {\r\n                // have to silence errors here;\r\n                // cannot allow unhandled errors while connecting to the database,\r\n                // as it will break the connection logic;\r\n                $events.unexpected('connect', e);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * @event disconnect\r\n     * @description\r\n     * Global notification of releasing a database connection back to the connection pool,\r\n     * i.e. releasing the virtual connection.\r\n     *\r\n     * However, when releasing a direct connection (created by calling {@link Database.connect} with parameter\r\n     * `{direct: true}`), this event represents a physical disconnection.\r\n     *\r\n     * The library will suppress any error thrown by the handler and write it into the console.\r\n     *\r\n     * @param {external:Client} client - $[pg.Client] object that represents connection with the database.\r\n     *\r\n     * @param {} dc - Database Context that was used when creating the database object (see {@link Database}).\r\n     *\r\n     * @example\r\n     *\r\n     * var options = {\r\n     *\r\n     *     // pg-promise initialization options...\r\n     *\r\n     *     disconnect: (client, dc) => {\r\n     *        var cp = client.connectionParameters;\r\n     *        console.log(\"Disconnecting from database:\", cp.database);\r\n     *     }\r\n     *\r\n     * };\r\n     */\r\n    disconnect: (ctx, client) => {\r\n        if (typeof ctx.options.disconnect === 'function') {\r\n            try {\r\n                ctx.options.disconnect(client, ctx.dc);\r\n            } catch (e) {\r\n                // have to silence errors here;\r\n                // cannot allow unhandled errors while disconnecting from the database,\r\n                // as it will break the disconnection logic;\r\n                $events.unexpected('disconnect', e);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * @event query\r\n     * @description\r\n     *\r\n     * Global notification of a query that's about to execute.\r\n     *\r\n     * Notification happens just before the query execution. And if the handler throws an error, the query execution\r\n     * will be rejected with that error.\r\n     *\r\n     * @param {object} e - Event Context Object.\r\n     *\r\n     * This is a shared-type object that's passed in with the following events: {@link event:query query},\r\n     * {@link event:receive receive}, {@link event:error error}, {@link event:task task} and {@link event:transact transact}.\r\n     *\r\n     * @param {String|Object} e.cn\r\n     *\r\n     * Set only for event {@link event:error error}, and only when the error is connection-related.\r\n     *\r\n     * It is a safe copy of the connection string/object that was used when initializing `db` - the database instance.\r\n     *\r\n     * If the original connection contains a password, the safe copy contains it masked with symbol `#`, so the connection\r\n     * can be logged safely, without exposing the password.\r\n     *\r\n     * @param {} e.dc\r\n     * Database Context that was used when creating the database object (see {@link Database}). It is set for all events.\r\n     *\r\n     * @param {String|Object} e.query\r\n     *\r\n     * Query string/object that was passed into the query method. This property is only set during events {@link event:query query}\r\n     * and {@link event:receive receive}.\r\n     *\r\n     * @param {external:Client} e.client\r\n     *\r\n     * $[pg.Client] object that represents the connection. It is set for all events, except for event {@link event:error error}\r\n     * when it is connection-related.\r\n     *\r\n     * @param {} e.params - Formatting parameters for the query.\r\n     *\r\n     * It is set only for events {@link event:query query}, {@link event:receive receive} and {@link event:error error}, and only\r\n     * when it is needed for logging. This library takes an extra step in figuring out when formatting parameters are of any value\r\n     * to the event logging:\r\n     * - when an error occurs related to the query formatting, event {@link event:error error} is sent with the property set.\r\n     * - when initialization parameter `pgFormat` is used, and all query formatting is done within the $[PG] library, events\r\n     * {@link event:query query} and {@link event:receive receive} will have this property set also, since this library no longer\r\n     * handles the query formatting.\r\n     *\r\n     * When this parameter is not set, it means one of the two things:\r\n     * - there were no parameters passed into the query method;\r\n     * - property `query` of this object already contains all the formatting values in it, so logging only the query is sufficient.\r\n     *\r\n     * @param {object} e.ctx\r\n     * _Task/Transaction Context_ object. See {@link Task.ctx} for details.\r\n     *\r\n     * This property is always set for events {@link event:task task} and {@link event:transact transact}, while for events\r\n     * {@link event:query query}, {@link event:receive receive} and {@link event:error error} it is only set when the event occurred\r\n     * while executing a task or transaction.\r\n     *\r\n     */\r\n    query: (options, context) => {\r\n        if (typeof options.query === 'function') {\r\n            try {\r\n                options.query(context);\r\n            } catch (e) {\r\n                // throwing an error during event 'query'\r\n                // will result in a reject for the request.\r\n                return e instanceof Error ? e : new $npm.utils.InternalError(e);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * @event receive\r\n     * @description\r\n     * Global notification of any data received from the database, coming from a regular query or from a stream.\r\n     *\r\n     * The event is fired before the data reaches the client, and only when receiving 1 or more records.\r\n     *\r\n     * This event notification serves two purposes:\r\n     *  - Providing selective data logging for debugging;\r\n     *  - Pre-processing data before it reaches the client.\r\n     *\r\n     * **NOTES:**\r\n     * - If you alter the size of `data` directly or through the `result` object, it may affect `QueryResultMask`\r\n     *   validation for regular queries, which is executed right after this notification.\r\n     * - When adding data pre-processing, you should consider possible performance penalty this may bring.\r\n     * - If the event handler throws an error, the original request will be rejected with that error.\r\n     *\r\n     * @param {array} data\r\n     * A non-empty array of received data objects/rows.\r\n     *\r\n     * If any of those objects are modified during notification, the client will receive the modified data.\r\n     *\r\n     * @param {object} result\r\n     * - original $[Result] object, if the data comes from a regular query, in which case `data = result.rows`.\r\n     * - `undefined` when the data comes from a stream.\r\n     *\r\n     * @param {object} e\r\n     * Event Context Object.\r\n     *\r\n     * This type of object is used by several events. See event {@link event:query query} for its complete documentation.\r\n     *\r\n     * @example\r\n     *\r\n     * // Example below shows the fastest way to camelize column names:\r\n     *\r\n     * var options = {\r\n     *     receive: (data, result, e) => {\r\n     *         camelizeColumns(data);\r\n     *     }\r\n     * };\r\n     *\r\n     * function camelizeColumns(data) {\r\n     *     var template = data[0];\r\n     *     for (var prop in template) {\r\n     *         var camel = pgp.utils.camelize(prop);\r\n     *         if (!(camel in template)) {\r\n     *             for (var i = 0; i < data.length; i++) {\r\n     *                 var d = data[i];\r\n     *                 d[camel] = d[prop];\r\n     *                 delete d[prop];\r\n     *             }\r\n     *         }\r\n     *     }\r\n     * }\r\n     */\r\n    receive: (options, data, result, context) => {\r\n        if (typeof options.receive === 'function') {\r\n            try {\r\n                options.receive(data, result, context);\r\n            } catch (e) {\r\n                // throwing an error during event 'receive'\r\n                // will result in a reject for the request.\r\n                return e instanceof Error ? e : new $npm.utils.InternalError(e);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * @event task\r\n     * @description\r\n     * Global notification of a task start / finish events.\r\n     *\r\n     * The library will suppress any error thrown by the handler and write it into the console.\r\n     *\r\n     * @param {object} e - Event Context Object.\r\n     *\r\n     * This type of object is used by several events. See event {@link event:query query}\r\n     * for its complete documentation.\r\n     *\r\n     * @example\r\n     *\r\n     * var options = {\r\n     *     task: e => {\r\n     *         if (e.ctx.finish) {\r\n     *             // this is a task->finish event;\r\n     *             console.log(\"Finish Time:\", e.ctx.finish);\r\n     *             if (e.ctx.success) {\r\n     *                 // e.ctx.result = resolved data;\r\n     *             } else {\r\n     *                 // e.ctx.result = error/rejection reason;\r\n     *             }\r\n     *         } else {\r\n     *             // this is a task->start event;\r\n     *             console.log(\"Start Time:\", e.ctx.start);\r\n     *         }\r\n     *     }\r\n     * };\r\n     *\r\n     */\r\n    task: (options, context) => {\r\n        if (typeof options.task === 'function') {\r\n            try {\r\n                options.task(context);\r\n            } catch (e) {\r\n                // silencing the error, to avoid breaking the task;\r\n                $events.unexpected('task', e);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * @event transact\r\n     * @description\r\n     * Global notification of a transaction start / finish events.\r\n     *\r\n     * The library will suppress any error thrown by the handler and write it into the console.\r\n     *\r\n     * @param {object} e - Event Context Object.\r\n     *\r\n     * This type of object is used by several events. See event {@link event:query query}\r\n     * for its complete documentation.\r\n     *\r\n     * @example\r\n     *\r\n     * var options = {\r\n     *     transact: e => {\r\n     *         if (e.ctx.finish) {\r\n     *             // this is a transaction->finish event;\r\n     *             console.log(\"Finish Time:\", e.ctx.finish);\r\n     *             if (e.ctx.success) {\r\n     *                 // e.ctx.result = resolved data;\r\n     *             } else {\r\n     *                 // e.ctx.result = error/rejection reason;\r\n     *             }\r\n     *         } else {\r\n     *             // this is a transaction->start event;\r\n     *             console.log(\"Start Time:\", e.ctx.start);\r\n     *         }\r\n     *     }\r\n     * };\r\n     *\r\n     */\r\n    transact: (options, context) => {\r\n        if (typeof options.transact === 'function') {\r\n            try {\r\n                options.transact(context);\r\n            } catch (e) {\r\n                // silencing the error, to avoid breaking the transaction;\r\n                $events.unexpected('transact', e);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * @event error\r\n     * @description\r\n     * Global notification of every error encountered by this library.\r\n     *\r\n     * The library will suppress any error thrown by the handler and write it into the console.\r\n     *\r\n     * @param {} err\r\n     * The error encountered, of the same value and type as it was reported.\r\n     *\r\n     * @param {object} e\r\n     * Event Context Object.\r\n     *\r\n     * This type of object is used by several events. See event {@link event:query query}\r\n     * for its complete documentation.\r\n     *\r\n     * @example\r\n     * var options = {\r\n     *\r\n     *     // pg-promise initialization options...\r\n     *\r\n     *     error: (err, e) => {\r\n     *\r\n     *         // e.dc = Database Context\r\n     *\r\n     *         if (e.cn) {\r\n     *             // this is a connection-related error\r\n     *             // cn = safe connection details passed into the library:\r\n     *             //      if password is present, it is masked by #\r\n     *         }\r\n     *\r\n     *         if (e.query) {\r\n     *             // query string is available\r\n     *             if (e.params) {\r\n     *                 // query parameters are available\r\n     *             }\r\n     *         }\r\n     *\r\n     *         if (e.ctx) {\r\n     *             // occurred inside a task or transaction\r\n     *         }\r\n     *       }\r\n     *\r\n     * };\r\n     *\r\n     */\r\n    error: (options, err, context) => {\r\n        if (typeof options.error === 'function') {\r\n            try {\r\n                options.error(err, context);\r\n            } catch (e) {\r\n                // have to silence errors here;\r\n                // throwing unhandled errors while handling an error\r\n                // notification is simply not acceptable.\r\n                $events.unexpected('error', e);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * @event extend\r\n     * @description\r\n     * Extends database protocol with custom methods and properties.\r\n     *\r\n     * Override this event to extend the existing access layer with your own functions and\r\n     * properties best suited for your application.\r\n     *\r\n     * The extension thus becomes available across all access layers:\r\n     *\r\n     * - Within the root/default database protocol;\r\n     * - Inside transactions, including nested ones;\r\n     * - Inside tasks, including nested ones.\r\n     *\r\n     * All pre-defined methods and properties are read-only, so you will get an error,\r\n     * if you try overriding them.\r\n     *\r\n     * The library will suppress any error thrown by the handler and write it into the console.\r\n     *\r\n     * @param {object} obj - Protocol object to be extended.\r\n     *\r\n     * @param {} dc - Database Context that was used when creating the database object.\r\n     *\r\n     * @example\r\n     *\r\n     * // In the example below we extend the protocol with function `addImage`\r\n     * // that will insert one binary image and resolve with the new record id.\r\n     *\r\n     * var options = {\r\n     *     extend: (obj, dc) => {\r\n     *         // obj = this;\r\n     *         // dc = database context;\r\n     *         obj.addImage = data => {\r\n     *             return obj.one(\"insert into images(data) values($1) returning id\", '\\\\x' + data);\r\n     *         }\r\n     *     }\r\n     * };\r\n     *\r\n     * @example\r\n     *\r\n     * // It is best to extend the protocol by adding whole entity repositories to it\r\n     * // as shown in the following example.\r\n     *\r\n     * // Users repository;\r\n     * function repUsers(obj, dc) {\r\n     *     // NOTE: You can change the implementation based on `dc`;\r\n     *     return {\r\n     *         add: (name, active) => {\r\n     *             return obj.none(\"insert into users values($1, $2)\", [name, active]);\r\n     *         },\r\n     *         delete: id => obj.none(\"delete from users where id = $1\", id)\r\n     *     }\r\n     * }\r\n     *\r\n     * // Overriding 'extend' event;\r\n     * var options = {\r\n     *     extend: (obj, dc) => {\r\n     *         // obj = this;\r\n     *         // dc = database context;\r\n     *         this.users = repUsers(this, dc);\r\n     *         // You can set different repositories based on `dc`\r\n     *     }\r\n     * };\r\n     *\r\n     * // Usage example:\r\n     * db.users.add(\"John\", true)\r\n     *     .then(() => {\r\n     *         // user added successfully;\r\n     *     })\r\n     *     .catch(error => {\r\n     *         // failed to add the user;\r\n     *     });\r\n     *\r\n     */\r\n    extend: (options, obj, dc) => {\r\n        if (typeof options.extend === 'function') {\r\n            try {\r\n                options.extend.call(obj, obj, dc);\r\n            } catch (e) {\r\n                // have to silence errors here;\r\n                // the result of throwing unhandled errors while\r\n                // extending the protocol would be unpredictable.\r\n                $events.unexpected('extend', e);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * @event unexpected\r\n     * @param {string} event - unhandled event name.\r\n     * @param {String|Error} e - unhandled error.\r\n     * @private\r\n     */\r\n    unexpected: (event, e) => {\r\n        // If you should ever get here, your app is definitely broken, and you need to fix\r\n        // your event handler to prevent unhandled errors during event notifications.\r\n        //\r\n        // Console output is suppressed when running tests, to avoid polluting test output\r\n        // with error messages that are intentional and of no value to the test.\r\n\r\n        /* istanbul ignore if */\r\n        if (!$npm.main.suppressErrors) {\r\n            var stack = e instanceof Error ? e.stack : new Error().stack;\r\n            $npm.con.error('Unexpected error in \\'%s\\' event handler.\\n%s\\n', event, stack);\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = $events;\r\n","/home/travis/build/npmtest/node-npmtest-pg-promise/node_modules/pg-promise/lib/database.js":"'use strict';\r\n\r\nvar $npm = {\r\n    con: require('manakin').local,\r\n    result: require('./result'),\r\n    special: require('./special'),\r\n    Context: require('./cnContext'),\r\n    events: require('./events'),\r\n    utils: require('./utils'),\r\n    connect: require('./connect'),\r\n    query: require('./query'),\r\n    task: require('./task')\r\n};\r\n\r\nvar $arr = require('./array');\r\n\r\n/**\r\n * @class Database\r\n * @description\r\n *\r\n * Represents the database protocol, extensible via event {@link event:extend extend}.\r\n * This type is not available directly, it can only be created via the library's base call.\r\n *\r\n * **IMPORTANT:**\r\n *\r\n * For any given connection, you should only create a single {@link Database} object in a separate module,\r\n * to be shared in your application (see the code example below). If instead you keep creating the {@link Database}\r\n * object dynamically, your application will suffer from loss in performance, and will be getting a warning in a\r\n * development environment (when `NODE_ENV` = `development`):\r\n *\r\n * `WARNING: Creating a duplicate database object for the same connection.`\r\n *\r\n * If you ever see this warning, rectify your {@link Database} object initialization, so there is only one object\r\n * per connection details. See the example provided below.\r\n *\r\n * See also: property `noWarnings` in {@link module:pg-promise Initialization Options}.\r\n *\r\n * @param {String|Object} cn\r\n * Database connection details, which can be:\r\n *\r\n * - a configuration object\r\n * - a connection string\r\n *\r\n * For details see {@link https://github.com/vitaly-t/pg-promise/wiki/Connection-Syntax Connection Syntax}.\r\n *\r\n * @param {} [dc]\r\n * Database Context.\r\n *\r\n * Any object or value to be propagated through the protocol, to allow implementations\r\n * and event handling that depend on the database context.\r\n *\r\n * This is mainly to facilitate the use of multiple databases which may need separate protocol\r\n * extensions, or different implementations within a single task / transaction callback,\r\n * depending on the database context.\r\n *\r\n * @returns {Database}\r\n *\r\n * @see\r\n *\r\n * {@link Database.query query},\r\n * {@link Database.none none},\r\n * {@link Database.one one},\r\n * {@link Database.oneOrNone oneOrNone},\r\n * {@link Database.many many},\r\n * {@link Database.manyOrNone manyOrNone},\r\n * {@link Database.any any},\r\n * {@link Database.func func},\r\n * {@link Database.proc proc},\r\n * {@link Database.result result},\r\n * {@link Database.map map},\r\n * {@link Database.each each},\r\n * {@link Database.stream stream},\r\n * {@link Database.task task},\r\n * {@link Database.tx tx},\r\n * {@link Database.connect connect},\r\n * {@link Database.$config $config},\r\n * {@link event:extend extend}\r\n *\r\n * @example\r\n * // Proper way to initialize and share the Database object\r\n *\r\n * // Loading and initializing the library:\r\n * var pgp = require('pg-promise')({\r\n *     // Initialization Options\r\n * });\r\n *\r\n * // Preparing the connection details:\r\n * var cn = \"postgres://username:password@host:port/database\";\r\n *\r\n * // Creating a new database instance from the connection details:\r\n * var db = pgp(cn);\r\n *\r\n * // Exporting the database object for shared use:\r\n * module.exports = db;\r\n */\r\nfunction Database(cn, dc, config) {\r\n\r\n    checkForDuplicates(cn, config);\r\n    setErrorHandler(config);\r\n\r\n    var $p = config.promise;\r\n\r\n    /**\r\n     * @method Database.connect\r\n     *\r\n     * @description\r\n     * Acquires a new or existing connection, based on the current connection parameters.\r\n     *\r\n     * This method creates a shared connection for executing a chain of queries against it.\r\n     * The connection must be released in the end of the chain by calling method `done()` on the connection object.\r\n     *\r\n     * This is an older, low-level approach to chaining queries on the same connection.\r\n     * A newer and safer approach is via methods {@link Database.task task} and {@link Database.tx tx} (for transactions),\r\n     * which allocate and release the shared connection automatically.\r\n     *\r\n     * **NOTE:** Even though this method exposes a {@link external:Client Client} object via property `client`,\r\n     * you cannot call `client.end()` directly, or it will print an error into the console:\r\n     * `Abnormal client.end() call, due to invalid code or failed server connection.`\r\n     * You should only call method `done()` to release the connection.\r\n     *\r\n     * @param {object} [options]\r\n     * @param {boolean} [options.direct=false]\r\n     * Creates the connection directly, through the {@link external:Client Client}, bypassing the connection pool.\r\n     *\r\n     * By default, all connections are acquired from the connection pool. If you set this option, the library will instead\r\n     * create a new {@link external:Client Client} object directly (separately from the pool), and then call its `connect` method.\r\n     *\r\n     * **WARNING:**\r\n     *\r\n     * Do not use this option for regular query execution, because it exclusively occupies one physical connection,\r\n     * and therefore cannot scale. This option is only suitable for global connection usage, such as database event listeners.\r\n     *\r\n     * @returns {external:Promise}\r\n     * A promise object that represents the connection result:\r\n     *  - resolves with the complete {@link Database} protocol, extended with:\r\n     *    - property `client` of type {@link external:Client Client} that represents the open connection\r\n     *    - method `done()` that must be called in the end, in order to release the connection\r\n     *  - rejects with a connection-related error when it fails to connect.\r\n     *\r\n     * @see\r\n     * {@link Database.task},\r\n     * {@link Database.tx}\r\n     *\r\n     * @example\r\n     *\r\n     * var sco; // shared connection object;\r\n     *\r\n     * db.connect()\r\n     *     .then(obj => {\r\n     *         // obj.client = new connected Client object;\r\n     *\r\n     *         sco = obj; // save the connection object;\r\n     *\r\n     *         // execute all the queries you need:\r\n     *         return sco.any('SELECT * FROM Users');\r\n     *     })\r\n     *     .then(data => {\r\n     *         // success\r\n     *     })\r\n     *     .catch(error => {\r\n     *         // error\r\n     *     })\r\n     *     .finally(() => {\r\n     *         // release the connection, if it was successful:\r\n     *         if (sco) {\r\n     *             sco.done();\r\n     *         }\r\n     *     });\r\n     *\r\n     */\r\n    this.connect = function (options) {\r\n        var ctx = createContext();\r\n        var self = {\r\n            // Generic query method;\r\n            query: function (query, values, qrm) {\r\n                if (!ctx.db) {\r\n                    throw new Error('Cannot execute a query on a disconnected client.');\r\n                }\r\n                return config.$npm.query.call(this, ctx, query, values, qrm);\r\n            },\r\n            // Connection release method;\r\n            done: () => {\r\n                if (!ctx.db) {\r\n                    throw new Error('Cannot invoke done() on a disconnected client.');\r\n                }\r\n                ctx.disconnect();\r\n            }\r\n        };\r\n        var method = (options && options.direct) ? 'direct' : 'pool';\r\n        return config.$npm.connect[method](ctx)\r\n            .then(db => {\r\n                ctx.connect(db);\r\n                self.client = db.client;\r\n                extend(ctx, self);\r\n                return self;\r\n            });\r\n    };\r\n\r\n    /**\r\n     * @method Database.query\r\n     *\r\n     * @description\r\n     * Executes a generic query request that expects the return data according to parameter `qrm`.\r\n     *\r\n     * @param {String|Object} query\r\n     * Query to be executed, which can any of the following types:\r\n     * - A non-empty query string\r\n     * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n     * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n     * - {@link QueryFile} object\r\n     *\r\n     * @param {array|value} [values]\r\n     * Query formatting parameters.\r\n     *\r\n     * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n     * - a single value - to replace all `$1` occurrences\r\n     * - an array of values - to replace all `$1`, `$2`, ... variables\r\n     * - an object - to apply $[Named Parameters] formatting\r\n     *\r\n     * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n     * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n     * as an override for its internal `values`.\r\n     *\r\n     * @param {queryResult} [qrm=queryResult.any]\r\n     * {@link queryResult Query Result Mask}\r\n     *\r\n     * @returns {external:Promise}\r\n     * A promise object that represents the query result.\r\n     *\r\n     * When the query result is an array, it is extended with hidden property `duration` -\r\n     * number of milliseconds it took the client to execute the query.\r\n     */\r\n    this.query = function (query, values, qrm) {\r\n        var self = this, ctx = createContext();\r\n        return config.$npm.connect.pool(ctx)\r\n            .then(db => {\r\n                ctx.connect(db);\r\n                return config.$npm.query.call(self, ctx, query, values, qrm);\r\n            })\r\n            .then(data => {\r\n                ctx.disconnect();\r\n                return data;\r\n            })\r\n            .catch(error => {\r\n                ctx.disconnect();\r\n                return $p.reject(error);\r\n            });\r\n    };\r\n\r\n    /**\r\n     * @member {object} Database.$config\r\n     * @readonly\r\n     * @description\r\n     * This is a hidden property, to help integrating type {@link Database} directly with third-party libraries.\r\n     *\r\n     * Properties available in the object:\r\n     * - `pgp` - instance of the entire library after initialization\r\n     * - `options` - the library's {@link module:pg-promise Initialization Options} object\r\n     * - `promiseLib` - instance of the promise library that's used\r\n     * - `promise` - generic promise interface that uses `promiseLib` via 3 basic methods:\r\n     *   - `promise((resolve, reject)=>{})` - to create a new promise\r\n     *   - `promise.resolve(value)` - to resolve with a value\r\n     *   - `promise.reject(value)` - to reject with a value\r\n     * - `version` - this library's version\r\n     * - `$npm` _(hidden property)_ - internal module cache\r\n     *\r\n     * @example\r\n     *\r\n     * // Using the promise protocol as configured by pg-promise:\r\n     *\r\n     * var $p = db.$config.promise;\r\n     *\r\n     * var resolvedPromise = $p.resolve('some data');\r\n     * var rejectedPromise = $p.reject('some reason');\r\n     *\r\n     * var newPromise = $p((resolve, reject) => {\r\n     *     // call either resolve(data) or reject(reason) here\r\n     * });\r\n     */\r\n    $npm.utils.addReadProp(this, '$config', config, true);\r\n\r\n    extend(createContext(), this); // extending root protocol;\r\n\r\n    function createContext() {\r\n        return new $npm.Context(cn, dc, config.options);\r\n    }\r\n\r\n    function transform(value, cb, thisArg) {\r\n        if (typeof cb === 'function') {\r\n            value = value.then(data => {\r\n                return cb.call(thisArg, data);\r\n            });\r\n        }\r\n        return value;\r\n    }\r\n\r\n    ////////////////////////////////////////////////////\r\n    // Injects additional methods into an access object,\r\n    // extending the protocol's base method 'query'.\r\n    function extend(ctx, obj) {\r\n\r\n        /**\r\n         * @method Database.none\r\n         * @description\r\n         * Executes a query that expects no data to be returned.\r\n         * If the query returns any kind of data, the method rejects.\r\n         *\r\n         * @param {String|Object} query\r\n         * Query to be executed, which can any of the following types:\r\n         * - A non-empty query string\r\n         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n         * - {@link QueryFile} object\r\n         *\r\n         * @param {array|value} [values]\r\n         * Query formatting parameters.\r\n         *\r\n         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n         * - a single value - to replace all `$1` occurrences\r\n         * - an array of values - to replace all `$1`, `$2`, ... variables\r\n         * - an object - to apply $[Named Parameters] formatting\r\n         *\r\n         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n         * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n         * as an override for its internal `values`.\r\n         *\r\n         * @returns {external:Promise}\r\n         * A promise object that represents the query result:\r\n         * - When no records are returned, it resolves with `null`.\r\n         * - When any data is returned, it rejects with {@link errors.QueryResultError QueryResultError}:\r\n         *   - `.message` = `No return data was expected.`\r\n         *   - `.code` = {@link errors.queryResultErrorCode.notEmpty queryResultErrorCode.notEmpty}\r\n         */\r\n        obj.none = function (query, values) {\r\n            return obj.query.call(this, query, values, $npm.result.none);\r\n        };\r\n\r\n        /**\r\n         * @method Database.one\r\n         * @description\r\n         * Executes a query that expects exactly one row of data.\r\n         * When 0 or more than 1 rows are returned, the method rejects.\r\n         *\r\n         * @param {String|Object} query\r\n         * Query to be executed, which can any of the following types:\r\n         * - A non-empty query string\r\n         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n         * - {@link QueryFile} object\r\n         *\r\n         * @param {array|value} [values]\r\n         * Query formatting parameters.\r\n         *\r\n         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n         * - a single value - to replace all `$1` occurrences\r\n         * - an array of values - to replace all `$1`, `$2`, ... variables\r\n         * - an object - to apply $[Named Parameters] formatting\r\n         *\r\n         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n         * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n         * as an override for its internal `values`.\r\n         *\r\n         * @param {function} [cb]\r\n         * Value transformation callback, to allow in-line value change.\r\n         * When specified, the return value replaces the original resolved value.\r\n         *\r\n         * The function takes only one parameter - value resolved from the query.\r\n         *\r\n         * @param {} [thisArg]\r\n         * Value to use as `this` when executing the transformation callback.\r\n         *\r\n         * @returns {external:Promise}\r\n         * A promise object that represents the query result:\r\n         * - When 1 row is returned, it resolves with that row as a single object.\r\n         * - When no rows are returned, it rejects with {@link errors.QueryResultError QueryResultError}:\r\n         *   - `.message` = `No data returned from the query.`\r\n         *   - `.code` = {@link errors.queryResultErrorCode.noData queryResultErrorCode.noData}\r\n         * - When multiple rows are returned, it rejects with {@link errors.QueryResultError QueryResultError}:\r\n         *   - `.message` = `Multiple rows were not expected.`\r\n         *   - `.code` = {@link errors.queryResultErrorCode.multiple queryResultErrorCode.multiple}\r\n         *\r\n         * @see\r\n         * {@link Database.oneOrNone oneOrNone}\r\n         *\r\n         * @example\r\n         *\r\n         * // a query with in-line value transformation:\r\n         * db.one('INSERT INTO Events VALUES($1) RETURNING id', [123], event => event.id)\r\n         *     .then(data=> {\r\n         *         // data = a new event id, rather than an object with it\r\n         *     });\r\n         *\r\n         * @example\r\n         *\r\n         * // a query with in-line value transformation + conversion:\r\n         * db.one('SELECT count(*) FROM Users', [], c => +c.count)\r\n         *     .then(count=> {\r\n         *         // count = a proper integer value, rather than an object with a string\r\n         *     });\r\n         *\r\n         */\r\n        obj.one = function (query, values, cb, thisArg) {\r\n            var v = obj.query.call(this, query, values, $npm.result.one);\r\n            return transform(v, cb, thisArg);\r\n        };\r\n\r\n        /**\r\n         * @method Database.many\r\n         * @description\r\n         * Executes a query that expects one or more rows.\r\n         * When the query returns no rows, the method rejects.\r\n         *\r\n         * @param {String|Object} query\r\n         * Query to be executed, which can any of the following types:\r\n         * - A non-empty query string\r\n         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n         * - {@link QueryFile} object\r\n         *\r\n         * @param {array|value} [values]\r\n         * Query formatting parameters.\r\n         *\r\n         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n         * - a single value - to replace all `$1` occurrences\r\n         * - an array of values - to replace all `$1`, `$2`, ... variables\r\n         * - an object - to apply $[Named Parameters] formatting\r\n         *\r\n         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n         * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n         * as an override for its internal `values`.\r\n         *\r\n         * @returns {external:Promise}\r\n         * A promise object that represents the query result:\r\n         * - When 1 or more rows are returned, it resolves with the array of rows. The array is extended with\r\n         *   hidden property `duration` - number of milliseconds it took the client to execute the query.\r\n         * - When no rows are returned, it rejects with {@link errors.QueryResultError QueryResultError}:\r\n         *   - `.message` = `No data returned from the query.`\r\n         *   - `.code` = {@link errors.queryResultErrorCode.noData queryResultErrorCode.noData}\r\n         */\r\n        obj.many = function (query, values) {\r\n            return obj.query.call(this, query, values, $npm.result.many);\r\n        };\r\n\r\n        /**\r\n         * @method Database.oneOrNone\r\n         * @description\r\n         * Executes a query that expects 0 or 1 rows.\r\n         * When the query returns more than 1 row, the method rejects.\r\n         *\r\n         * @param {String|Object} query\r\n         * Query to be executed, which can any of the following types:\r\n         * - A non-empty query string\r\n         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n         * - {@link QueryFile} object\r\n         *\r\n         * @param {array|value} [values]\r\n         * Query formatting parameters.\r\n         *\r\n         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n         * - a single value - to replace all `$1` occurrences\r\n         * - an array of values - to replace all `$1`, `$2`, ... variables\r\n         * - an object - to apply $[Named Parameters] formatting\r\n         *\r\n         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n         * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n         * as an override for its internal `values`.\r\n         *\r\n         * @param {function} [cb]\r\n         * Value transformation callback, to allow in-line value change.\r\n         * When specified, the return value replaces the original resolved value.\r\n         *\r\n         * The function takes only one parameter - value resolved from the query.\r\n         *\r\n         * @param {} [thisArg]\r\n         * Value to use as `this` when executing the transformation callback.\r\n         *\r\n         * @returns {external:Promise}\r\n         * A promise object that represents the query result:\r\n         * - When no rows are returned, it resolves with `null`.\r\n         * - When 1 row is returned, it resolves with that row as a single object.\r\n         * - When multiple rows are returned, it rejects with {@link errors.QueryResultError QueryResultError}:\r\n         *   - `.message` = `Multiple rows were not expected.`\r\n         *   - `.code` = {@link errors.queryResultErrorCode.multiple queryResultErrorCode.multiple}\r\n         *\r\n         * @see\r\n         * {@link Database.one one},\r\n         * {@link Database.none none},\r\n         * {@link Database.manyOrNone manyOrNone}\r\n         *\r\n         * @example\r\n         *\r\n         * // a query with in-line value transformation:\r\n         * db.oneOrNone('SELECT id FROM Events WHERE type = $1', ['entry'], e => e && e.id)\r\n         *     .then(data=> {\r\n         *         // data = the event id or null (rather than object or null)\r\n         *     });\r\n         *\r\n         */\r\n        obj.oneOrNone = function (query, values, cb, thisArg) {\r\n            var v = obj.query.call(this, query, values, $npm.result.one | $npm.result.none);\r\n            return transform(v, cb, thisArg);\r\n        };\r\n\r\n        /**\r\n         * @method Database.manyOrNone\r\n         * @description\r\n         * Executes a query that expects any number of rows.\r\n         *\r\n         * @param {String|Object} query\r\n         * Query to be executed, which can any of the following types:\r\n         * - A non-empty query string\r\n         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n         * - {@link QueryFile} object\r\n         *\r\n         * @param {array|value} [values]\r\n         * Query formatting parameters.\r\n         *\r\n         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n         * - a single value - to replace all `$1` occurrences\r\n         * - an array of values - to replace all `$1`, `$2`, ... variables\r\n         * - an object - to apply $[Named Parameters] formatting\r\n         *\r\n         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n         * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n         * as an override for its internal `values`.\r\n         *\r\n         * @returns {external:Promise}\r\n         * A promise object that represents the query result:\r\n         * - When no rows are returned, it resolves with an empty array.\r\n         * - When 1 or more rows are returned, it resolves with the array of rows.\r\n         *\r\n         * The resolved array is extended with hidden property `duration` - number of milliseconds\r\n         * it took the client to execute the query.\r\n         *\r\n         * @see\r\n         * {@link Database.any any},\r\n         * {@link Database.many many},\r\n         * {@link Database.none none}\r\n         *\r\n         */\r\n        obj.manyOrNone = function (query, values) {\r\n            return obj.query.call(this, query, values, $npm.result.many | $npm.result.none);\r\n        };\r\n\r\n        /**\r\n         * @method Database.any\r\n         * @description\r\n         * Executes a query that expects any number of rows.\r\n         * This is simply a shorter alias for method {@link Database.manyOrNone manyOrNone}.\r\n         *\r\n         * @param {String|Object} query\r\n         * Query to be executed, which can any of the following types:\r\n         * - A non-empty query string\r\n         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n         * - {@link QueryFile} object\r\n         *\r\n         * @param {array|value} [values]\r\n         * Query formatting parameters.\r\n         *\r\n         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n         * - a single value - to replace all `$1` occurrences\r\n         * - an array of values - to replace all `$1`, `$2`, ... variables\r\n         * - an object - to apply $[Named Parameters] formatting\r\n         *\r\n         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n         * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n         * as an override for its internal `values`.\r\n         *\r\n         * @returns {external:Promise}\r\n         * A promise object that represents the query result:\r\n         * - When no rows are returned, it resolves with an empty array.\r\n         * - When 1 or more rows are returned, it resolves with the array of rows.\r\n         *\r\n         * The resolved array is extended with hidden property `duration` - number of milliseconds\r\n         * it took the client to execute the query.\r\n         *\r\n         * @see\r\n         * {@link Database.manyOrNone manyOrNone},\r\n         * {@link Database.map map},\r\n         * {@link Database.each each}\r\n         *\r\n         */\r\n        obj.any = function (query, values) {\r\n            return obj.query.call(this, query, values, $npm.result.any);\r\n        };\r\n\r\n        /**\r\n         * @method Database.result\r\n         * @description\r\n         * Executes a query without any expectation for the return data, to resolve with the\r\n         * original $[Result] object when successful.\r\n         *\r\n         * @param {String|Object} query\r\n         * Query to be executed, which can any of the following types:\r\n         * - A non-empty query string\r\n         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n         * - {@link QueryFile} object\r\n         *\r\n         * @param {array|value} [values]\r\n         * Query formatting parameters.\r\n         *\r\n         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n         * - a single value - to replace all `$1` occurrences\r\n         * - an array of values - to replace all `$1`, `$2`, ... variables\r\n         * - an object - to apply $[Named Parameters] formatting\r\n         *\r\n         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n         * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n         * as an override for its internal `values`.\r\n         *\r\n         * @param {function} [cb]\r\n         * Value transformation callback, to allow in-line value change.\r\n         * When specified, the return value replaces the original resolved value.\r\n         *\r\n         * The function takes only one parameter - value resolved from the query.\r\n         *\r\n         * @param {} [thisArg]\r\n         * Value to use as `this` when executing the transformation callback.\r\n         *\r\n         * @returns {external:Promise}\r\n         * A promise object that represents the query result:\r\n         * - resolves with the original $[Result] object, extended with property `duration` -\r\n         *   number of milliseconds it took the client to execute the query.\r\n         *\r\n         * @example\r\n         *\r\n         * // use of value transformation:\r\n         * // deleting rows and returning the number of rows deleted\r\n         * db.result('DELETE FROM Events WHERE id = $1', [123], r => r.rowCount)\r\n         *     .then(data=> {\r\n         *         // data = number of rows that were deleted\r\n         *     });\r\n         *\r\n         * @example\r\n         *\r\n         * // use of value transformation:\r\n         * // getting only column details from a table\r\n         * db.result('SELECT * FROM Users LIMIT 0', null, r => r.fields)\r\n         *     .then(data=> {\r\n         *         // data = array of column descriptors\r\n         *     });\r\n         *\r\n         */\r\n        obj.result = function (query, values, cb, thisArg) {\r\n            var v = obj.query.call(this, query, values, $npm.special.cache.resultQuery);\r\n            return transform(v, cb, thisArg);\r\n        };\r\n\r\n        /**\r\n         * @method Database.stream\r\n         * @description\r\n         * Custom data streaming, with the help of $[pg-query-stream].\r\n         *\r\n         * This method doesn't work with the $[Native Bindings], and if option `pgNative`\r\n         * is set, it will reject with `Streaming doesn't work with Native Bindings.`\r\n         *\r\n         * @param {QueryStream} qs\r\n         * Stream object of type $[QueryStream].\r\n         *\r\n         * @param {Database.streamInitCB} initCB\r\n         * Stream initialization callback.\r\n         *\r\n         * It is invoked with the same `this` context as the calling method.\r\n         *\r\n         * @returns {external:Promise}\r\n         * Result of the streaming operation.\r\n         *\r\n         * Once the streaming has finished successfully, the method resolves with\r\n         * `{processed, duration}`:\r\n         * - `processed` - total number of rows processed;\r\n         * - `duration` - streaming duration, in milliseconds.\r\n         *\r\n         * Possible rejections messages:\r\n         * - `Invalid or missing stream object.`\r\n         * - `Invalid stream state.`\r\n         * - `Invalid or missing stream initialization callback.`\r\n         */\r\n        obj.stream = function (qs, init) {\r\n            return obj.query.call(this, qs, init, $npm.special.cache.streamQuery);\r\n        };\r\n\r\n        /**\r\n         * @method Database.func\r\n         * @description\r\n         * Executes a query against a database function by its name: `SELECT * FROM funcName(values)`.\r\n         *\r\n         * @param {string} funcName\r\n         * Name of the function to be executed.\r\n         *\r\n         * @param {array|value} [values]\r\n         * Parameters for the function - one value or an array of values.\r\n         *\r\n         * @param {queryResult} [qrm=queryResult.any] - {@link queryResult Query Result Mask}.\r\n         *\r\n         * @returns {external:Promise}\r\n         *\r\n         * A promise object as returned from method {@link Database.query query}, according to parameter `qrm`.\r\n         *\r\n         * @see\r\n         * {@link Database.query query},\r\n         * {@link Database.proc proc}\r\n         */\r\n        obj.func = function (funcName, values, qrm) {\r\n            return obj.query.call(this, {\r\n                funcName: funcName\r\n            }, values, qrm);\r\n        };\r\n\r\n        /**\r\n         * @method Database.proc\r\n         * @description\r\n         * Executes a query against a stored procedure via its name: `select * from procName(values)`,\r\n         * expecting back 0 or 1 rows.\r\n         *\r\n         * The method simply forwards into {@link Database.func func}`(procName, values, queryResult.one|queryResult.none)`.\r\n         *\r\n         * @param {string} procName\r\n         * Name of the stored procedure to be executed.\r\n         *\r\n         * @param {array|value} [values]\r\n         * Parameters for the procedure - one value or an array of values.\r\n         *\r\n         * @param {function} [cb]\r\n         * Value transformation callback, to allow in-line value change.\r\n         * When specified, the return value replaces the original resolved value.\r\n         *\r\n         * The function takes only one parameter - value resolved from the query.\r\n         *\r\n         * @param {} [thisArg]\r\n         * Value to use as `this` when executing the transformation callback.\r\n         *\r\n         * @returns {external:Promise}\r\n         *\r\n         * It calls {@link Database.func func}(`procName`, `values`, `queryResult.one|queryResult.none`),\r\n         * and then returns the same result as method {@link Database.oneOrNone oneOrNone}.\r\n         *\r\n         * @see\r\n         * {@link Database.oneOrNone oneOrNone},\r\n         * {@link Database.func func}\r\n         */\r\n        obj.proc = function (procName, values, cb, thisArg) {\r\n            var v = obj.func.call(this, procName, values, $npm.result.one | $npm.result.none);\r\n            return transform(v, cb, thisArg);\r\n        };\r\n\r\n        /**\r\n         * @method Database.map\r\n         * @description\r\n         * Creates a new array with the results of calling a provided function on every element in the array of rows\r\n         * resolved by method {@link Database.any any}.\r\n         *\r\n         * It is a convenience method to reduce the following code:\r\n         *\r\n         * ```js\r\n         * db.any(query, values)\r\n         *     .then(data => {\r\n         *         return data.map((row, index, data) => {\r\n         *              // return a new element\r\n         *         });\r\n         *     });\r\n         * ```\r\n         *\r\n         * In addition to much shorter code, it offers the following benefits:\r\n         *\r\n         * - Use of a custom iterator has a much better performance than the standard {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map Array.map}\r\n         * - Automatic `this` context through the database protocol\r\n         *\r\n         * @param {String|Object} query\r\n         * Query to be executed, which can any of the following types:\r\n         * - A non-empty query string\r\n         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n         * - {@link QueryFile} object\r\n         *\r\n         * @param {array|value} values\r\n         * Query formatting parameters.\r\n         *\r\n         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n         * - a single value - to replace all `$1` occurrences\r\n         * - an array of values - to replace all `$1`, `$2`, ... variables\r\n         * - an object - to apply $[Named Parameters] formatting\r\n         *\r\n         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n         * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n         * as an override for its internal `values`.\r\n         *\r\n         * @param {function} cb\r\n         * Function that produces an element of the new array, taking three arguments:\r\n         * - `row` - the current row object being processed in the array\r\n         * - `index` - the index of the current row being processed in the array\r\n         * - `data` - the original array of rows resolved by method {@link Database.any any}\r\n         *\r\n         * @param {} [thisArg]\r\n         * Value to use as `this` when executing the callback.\r\n         *\r\n         * @returns {external:Promise}\r\n         * Resolves with the new array of values returned from the callback. The array is extended with\r\n         * hidden property `duration` - number of milliseconds it took the client to execute the query.\r\n         *\r\n         * @see\r\n         * {@link Database.any any},\r\n         * {@link Database.each each},\r\n         * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map Array.map}\r\n         *\r\n         * @example\r\n         *\r\n         * db.map('SELECT id FROM Users WHERE status = $1', ['active'], row => row.id)\r\n         *     .then(data => {\r\n         *         // data = array of active user id-s\r\n         *     })\r\n         *     .catch(error => {\r\n         *        // error\r\n         *     });\r\n         *\r\n         * @example\r\n         *\r\n         * db.tx(t => {\r\n         *     return t.map('SELECT id FROM Users WHERE status = $1', ['active'], row => {\r\n         *        return t.none('UPDATE Events SET checked = $1 WHERE userId = $2', [true, row.id]);\r\n         *     }).then(t.batch);\r\n         * })\r\n         *     .then(data => {\r\n         *         // success\r\n         *     })\r\n         *     .catch(error => {\r\n         *         // error\r\n         *     });\r\n         *\r\n         * @example\r\n         *\r\n         * // Build a list of active users, each with the list of user events:\r\n         * db.task(t => {\r\n         *     return t.map('SELECT id FROM Users WHERE status = $1', ['active'], user => {\r\n         *         return t.any('SELECT * FROM Events WHERE userId = $1', user.id)\r\n         *             .then(events=> {\r\n         *                 user.events = events;\r\n         *                 return user;\r\n         *             });\r\n         *     }).then(t.batch);\r\n         * })\r\n         *     .then(data => {\r\n         *         // success\r\n         *     })\r\n         *     .catch(error => {\r\n         *         // error\r\n         *     });\r\n         *\r\n         */\r\n        obj.map = function (query, values, cb, thisArg) {\r\n            return obj.any.call(this, query, values)\r\n                .then(data => {\r\n                    var result = $arr.map(data, cb, thisArg);\r\n                    $npm.utils.addReadProp(result, 'duration', data.duration, true);\r\n                    return result;\r\n                });\r\n        };\r\n\r\n        /**\r\n         * @method Database.each\r\n         * @description\r\n         * Executes a provided function once per array element, for an array of rows resolved by method {@link Database.any any}.\r\n         *\r\n         * It is a convenience method to reduce the following code:\r\n         *\r\n         * ```js\r\n         * db.any(query, values)\r\n         *     .then(data => {\r\n         *         data.forEach((row, index, data) => {\r\n         *              // process the row\r\n         *         });\r\n         *         return data;\r\n         *     });\r\n         * ```\r\n         *\r\n         * In addition to much shorter code, it offers the following benefits:\r\n         *\r\n         * - Use of a custom iterator has a much better performance than the regular {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach Array.forEach}\r\n         * - Automatic `this` context through the database protocol\r\n         *\r\n         * @param {String|Object} query\r\n         * Query to be executed, which can any of the following types:\r\n         * - A non-empty query string\r\n         * - Prepared Statement `{name, text, values, ...}` or {@link PreparedStatement} object\r\n         * - Parameterized Query `{text, values, ...}` or {@link ParameterizedQuery} object\r\n         * - {@link QueryFile} object\r\n         *\r\n         * @param {array|value} [values]\r\n         * Query formatting parameters.\r\n         *\r\n         * When `query` is of type `string` or a {@link QueryFile} object, the `values` can be:\r\n         * - a single value - to replace all `$1` occurrences\r\n         * - an array of values - to replace all `$1`, `$2`, ... variables\r\n         * - an object - to apply $[Named Parameters] formatting\r\n         *\r\n         * When `query` is a Prepared Statement or a Parameterized Query (or their class types),\r\n         * and `values` is not `null` or `undefined`, it is automatically set within such object,\r\n         * as an override for its internal `values`.\r\n         *\r\n         * @param {function} cb\r\n         * Function to execute for each row, taking three arguments:\r\n         * - `row` - the current row object being processed in the array\r\n         * - `index` - the index of the current row being processed in the array\r\n         * - `data` - the array of rows resolved by method {@link Database.any any}\r\n         *\r\n         * @param {} [thisArg]\r\n         * Value to use as `this` when executing the callback.\r\n         *\r\n         * @returns {external:Promise}\r\n         * Resolves with the original array of rows, extended with hidden property `duration` -\r\n         * number of milliseconds it took the client to execute the query.\r\n         *\r\n         * @see\r\n         * {@link Database.any any},\r\n         * {@link Database.map map},\r\n         * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach Array.forEach}\r\n         *\r\n         * @example\r\n         *\r\n         * db.each('SELECT id, code, name FROM Events', [], row => {\r\n         *     row.code = +row.code; // leading `+` is short for `parseInt()`\r\n         * })\r\n         *     .then(data => {\r\n         *         // data = array of events, with 'code' converted into integer\r\n         *     })\r\n         *     .catch(error => {\r\n         *         // error\r\n         *     });\r\n         *\r\n         */\r\n        obj.each = function (query, values, cb, thisArg) {\r\n            return obj.any.call(this, query, values)\r\n                .then(data => {\r\n                    $arr.forEach(data, cb, thisArg);\r\n                    return data;\r\n                });\r\n        };\r\n\r\n        /**\r\n         * @method Database.task\r\n         * @description\r\n         * Executes a callback function (or $[ES6 generator]) with an automatically managed connection.\r\n         *\r\n         * This method should be used whenever executing more than one query at once, so the allocated connection\r\n         * is reused between all queries, and released only after the task has finished.\r\n         *\r\n         * The callback function is called with one parameter - database protocol (same as `this`), extended with methods\r\n         * {@link Task.batch batch}, {@link Task.page page}, {@link Task.sequence sequence}, plus property {@link Task.ctx ctx} -\r\n         * the task context object.\r\n         *\r\n         * See class {@link Task} for more details.\r\n         *\r\n         * @param {} tag/cb\r\n         * When the method takes only one parameter, it must be the callback function (or $[ES6 generator]) for the task.\r\n         * However, when calling the method with 2 parameters, the first one is always the `tag` - traceable context for the\r\n         * task (see $[tags]).\r\n         *\r\n         * @param {function|generator} [cb]\r\n         * Task callback function (or $[ES6 generator]), if it is not `undefined`, or else the callback is expected to\r\n         * be passed in as the first parameter.\r\n         *\r\n         * @returns {external:Promise}\r\n         *\r\n         * A promise object that represents the result from the callback function.\r\n         *\r\n         * @see\r\n         * {@link Task},\r\n         * {@link Database.tx tx},\r\n         * $[tags]\r\n         *\r\n         * @example\r\n         *\r\n         * // using the regular callback syntax:\r\n         * db.task(t => {\r\n         *         // t.ctx = task context object\r\n         *\r\n         *         return t.one('SELECT id FROM Users WHERE name = $1', 'John')\r\n         *             .then(user=> {\r\n         *                 return t.any('SELECT * FROM Events WHERE userId = $1', user.id);\r\n         *             });\r\n         *     })\r\n         *     .then(data => {\r\n         *         // success\r\n         *         // data = as returned from the task's callback\r\n         *     })\r\n         *     .catch(error => {\r\n         *         // error\r\n         *     });\r\n         *\r\n         * @example\r\n         *\r\n         * // using the ES6 arrow syntax:\r\n         * db.task(t => {\r\n         *         // t.ctx = task context object\r\n         *         \r\n         *         return t.one('SELECT id FROM Users WHERE name = $1', 'John')\r\n         *             .then(user=> {\r\n         *                 return t.any('SELECT * FROM Events WHERE userId = $1', user.id);\r\n         *             });\r\n         *     })\r\n         *     .then(data=> {\r\n         *         // success\r\n         *         // data = as returned from the task's callback\r\n         *     })\r\n         *     .catch(error=> {\r\n         *         // error\r\n         *     });\r\n         *\r\n         * @example\r\n         *\r\n         * // using an ES6 generator for the callback:\r\n         * db.task(function * (t) {\r\n         *         // t.ctx = task context object\r\n         *\r\n         *         let user = yield t.one('SELECT id FROM Users WHERE name = $1', 'John');\r\n         *         return yield t.any('SELECT * FROM Events WHERE userId = $1', user.id);\r\n         *     })\r\n         *     .then(data => {\r\n         *         // success\r\n         *         // data = as returned from the task's callback\r\n         *     })\r\n         *     .catch(error => {\r\n         *         // error\r\n         *     });\r\n         *\r\n         */\r\n        obj.task = function (p1, p2) {\r\n            return taskProcessor.call(this, p1, p2, false);\r\n        };\r\n\r\n        /**\r\n         * @method Database.tx\r\n         * @description\r\n         * Executes a callback function (or $[ES6 generator]) as a transaction.\r\n         *\r\n         * A transaction simply wraps a regular {@link Database.task task} in automatic queries:\r\n         * - it executes `BEGIN` just before invoking the callback function\r\n         * - it executes `COMMIT`, if the callback didn't throw any error or return a rejected promise\r\n         * - it executes `ROLLBACK`, if the callback did throw an error or return a rejected promise\r\n         *\r\n         * The callback function is called with one parameter - database protocol (same as `this`), extended with methods\r\n         * {@link Task.batch batch}, {@link Task.page page}, {@link Task.sequence sequence}, plus property {@link Task.ctx ctx} -\r\n         * the transaction context object.\r\n         *\r\n         * See class {@link Task} for more details.\r\n         *\r\n         * Note that transactions should be chosen over tasks only where they are necessary, because unlike regular tasks,\r\n         * transactions are blocking operations, and must be used with caution.\r\n         *\r\n         * @param {} tag/cb\r\n         * When the method takes only one parameter, it must be the callback function (or $[ES6 generator]) for the transaction.\r\n         * However, when calling the method with 2 parameters, the first one is always the `tag` - traceable context for the\r\n         * transaction (see $[tags]).\r\n         *\r\n         * @param {function|generator} [cb]\r\n         * Transaction callback function (or $[ES6 generator]), if it is not `undefined`, or else the callback is expected to be\r\n         * passed in as the first parameter.\r\n         *\r\n         * @returns {external:Promise}\r\n         *\r\n         * A promise object that represents the result from the callback function.\r\n         *\r\n         * @see\r\n         * {@link Task},\r\n         * {@link Database.task},\r\n         * $[tags]\r\n         *\r\n         * @example\r\n         *\r\n         * // using the regular callback syntax:\r\n         * db.tx(t => {\r\n         *         // t.ctx = transaction context object\r\n         *\r\n         *         return t.one('INSERT INTO Users(name, age) VALUES($1, $2) RETURNING id', ['Mike', 25])\r\n         *             .then(user=> {\r\n         *                 return t.none('INSERT INTO Events(userId, name) VALUES($1, $2)', [user.id, 'created']);\r\n         *             });\r\n         *     })\r\n         *     .then(data => {\r\n         *         // success\r\n         *         // data = as returned from the transaction's callback\r\n         *     })\r\n         *     .catch(error => {\r\n         *         // error\r\n         *     });\r\n         *\r\n         * @example\r\n         *\r\n         * // using the ES6 arrow syntax:\r\n         * db.tx(t=> {\r\n         *         // t.ctx = transaction context object\r\n         *         \r\n         *         return t.one('INSERT INTO Users(name, age) VALUES($1, $2) RETURNING id', ['Mike', 25])\r\n         *             .then(user=> {\r\n         *                 return t.batch([\r\n         *                     t.none('INSERT INTO Events(userId, name) VALUES($1, $2)', [user.id, 'created']),\r\n         *                     t.none('INSERT INTO Events(userId, name) VALUES($1, $2)', [user.id, 'login'])\r\n         *                 ]);\r\n         *             });\r\n         *     })\r\n         *     .then(data=> {\r\n         *         // success\r\n         *         // data = as returned from the transaction's callback\r\n         *     })\r\n         *     .catch(error=> {\r\n         *         // error\r\n         *     });\r\n         *\r\n         * @example\r\n         *\r\n         * // using an ES6 generator for the callback:\r\n         * db.tx(function * (t) {\r\n         *         // t.ctx = transaction context object\r\n         *\r\n         *         let user = yield t.one('INSERT INTO Users(name, age) VALUES($1, $2) RETURNING id', ['Mike', 25]);\r\n         *         return yield t.none('INSERT INTO Events(userId, name) VALUES($1, $2)', [user.id, 'created']);\r\n         *     })\r\n         *     .then(data => {\r\n         *         // success\r\n         *         // data = as returned from the transaction's callback\r\n         *     })\r\n         *     .catch(error => {\r\n         *         // error\r\n         *     });\r\n         *\r\n         */\r\n        obj.tx = function (p1, p2) {\r\n            return taskProcessor.call(this, p1, p2, true);\r\n        };\r\n\r\n        // Task method;\r\n        // Resolves with result from the callback function;\r\n        function taskProcessor(p1, p2, isTX) {\r\n\r\n            var tag, // tag object/value;\r\n                taskCtx = ctx.clone(); // task context object;\r\n\r\n            if (isTX) {\r\n                taskCtx.txLevel = taskCtx.txLevel >= 0 ? (taskCtx.txLevel + 1) : 0;\r\n            }\r\n\r\n            if (this !== obj) {\r\n                taskCtx.context = this; // calling context object;\r\n            }\r\n\r\n            taskCtx.cb = p1; // callback function;\r\n\r\n            // allow inserting a tag in front of the callback\r\n            // function, for better code readability;\r\n            if (p2 !== undefined) {\r\n                tag = p1; // overriding any default tag;\r\n                taskCtx.cb = p2;\r\n            }\r\n\r\n            var cb = taskCtx.cb;\r\n\r\n            if (typeof cb !== 'function') {\r\n                return $p.reject(new TypeError('Callback function is required for the ' + (isTX ? 'transaction.' : 'task.')));\r\n            }\r\n\r\n            if (tag === undefined) {\r\n                if (cb.tag !== undefined) {\r\n                    // use the default tag associated with the task:\r\n                    tag = cb.tag;\r\n                } else {\r\n                    if (cb.name) {\r\n                        tag = cb.name; // use the function name as tag;\r\n                    }\r\n                }\r\n            }\r\n\r\n            var tsk = new config.$npm.task(taskCtx, tag, isTX, config); // eslint-disable-line\r\n\r\n            extend(taskCtx, tsk);\r\n\r\n            if (taskCtx.db) {\r\n                // reuse existing connection;\r\n                $npm.utils.addReadProp(tsk.ctx, 'isFresh', taskCtx.db.isFresh);\r\n                return config.$npm.task.exec(taskCtx, tsk, isTX, config);\r\n            }\r\n\r\n            // connection required;\r\n            return config.$npm.connect.pool(taskCtx)\r\n                .then(db => {\r\n                    taskCtx.connect(db);\r\n                    $npm.utils.addReadProp(tsk.ctx, 'isFresh', db.isFresh);\r\n                    return config.$npm.task.exec(taskCtx, tsk, isTX, config);\r\n                })\r\n                .then(data => {\r\n                    taskCtx.disconnect();\r\n                    return data;\r\n                })\r\n                .catch(error => {\r\n                    taskCtx.disconnect();\r\n                    return $p.reject(error);\r\n                });\r\n        }\r\n\r\n        // lock all default properties to read-only,\r\n        // to prevent override by the client.\r\n        $npm.utils.lock(obj, false, ctx.options);\r\n\r\n        // extend the protocol;\r\n        $npm.events.extend(ctx.options, obj, ctx.dc);\r\n\r\n        // freeze the protocol permanently;\r\n        $npm.utils.lock(obj, true, ctx.options);\r\n    }\r\n\r\n}\r\n\r\nvar jsHandled, nativeHandled, dbObjects = {};\r\n\r\nfunction checkForDuplicates(cn, config) {\r\n    var cnKey = normalizeConnection(cn);\r\n    if (cnKey in dbObjects) {\r\n        if (!config.options.noWarnings) {\r\n            $npm.con.warn('WARNING: Creating a duplicate database object for the same connection.\\n%s\\n',\r\n                $npm.utils.getLocalStack(5));\r\n        }\r\n    } else {\r\n        dbObjects[cnKey] = true;\r\n    }\r\n}\r\n\r\n/**\r\n * For connections that are objects it reorders the keys alphabetically,\r\n * and then serializes the result into a JSON string.\r\n *\r\n * @param {string|object} cn - connection string or object\r\n *\r\n * @private\r\n */\r\nfunction normalizeConnection(cn) {\r\n    if (typeof cn === 'object') {\r\n        var obj = {}, keys = Object.keys(cn).sort();\r\n        $arr.forEach(keys, name => {\r\n            obj[name] = cn[name];\r\n        });\r\n        cn = obj;\r\n    }\r\n    return JSON.stringify(cn);\r\n}\r\n\r\nfunction setErrorHandler(config) {\r\n    // we do not do code coverage specific to Native Bindings:\r\n    // istanbul ignore if\r\n    if (config.options.pgNative) {\r\n        if (!nativeHandled) {\r\n            config.pgp.pg.on('error', onError);\r\n            nativeHandled = true;\r\n        }\r\n    } else {\r\n        if (!jsHandled) {\r\n            config.pgp.pg.on('error', onError);\r\n            jsHandled = true;\r\n        }\r\n    }\r\n}\r\n\r\n// this event only happens when the connection is lost physically,\r\n// which cannot be tested automatically; removing from coverage:\r\n// istanbul ignore next\r\nfunction onError(err, client) {\r\n    var ctx = client.$ctx;\r\n    $npm.events.error(ctx.options, err, {\r\n        cn: $npm.utils.getSafeConnection(ctx.cn),\r\n        dc: ctx.dc\r\n    });\r\n}\r\n\r\nmodule.exports = config => {\r\n    var npm = config.$npm;\r\n    npm.connect = npm.connect || $npm.connect(config);\r\n    npm.query = npm.query || $npm.query(config);\r\n    npm.task = npm.task || $npm.task(config);\r\n    return Database;\r\n};\r\n\r\n/**\r\n * @callback Database.streamInitCB\r\n * @description\r\n * Stream initialization callback, used by {@link Database.stream}.\r\n *\r\n * @param {external:Stream} stream\r\n * Stream object to initialize streaming.\r\n *\r\n * @example\r\n * var QueryStream = require('pg-query-stream');\r\n * var JSONStream = require('JSONStream');\r\n *\r\n * // you can also use pgp.as.format(query, values, options)\r\n * // to format queries properly, via pg-promise;\r\n * var qs = new QueryStream('select * from users');\r\n *\r\n * db.stream(qs, stream => {\r\n *         // initiate streaming into the console:\r\n *         stream.pipe(JSONStream.stringify()).pipe(process.stdout);\r\n *     })\r\n *     .then(data => {\r\n *         console.log(\"Total rows processed:\", data.processed,\r\n *           \"Duration in milliseconds:\", data.duration);\r\n *     })\r\n *     .catch(error => {\r\n *         // error;\r\n *     });\r\n */\r\n\r\n/**\r\n * @external Stream\r\n * @see https://nodejs.org/api/stream.html\r\n */\r\n","/home/travis/build/npmtest/node-npmtest-pg-promise/node_modules/pg-promise/lib/special.js":"'use strict';\r\n\r\n/////////////////////////////\r\n// Special Query type;\r\nfunction SpecialQuery(type) {\r\n    this.isStream = type === 'stream';\r\n    this.isResult = type === 'result';\r\n}\r\n\r\nvar cache = {\r\n    resultQuery: new SpecialQuery('result'),\r\n    streamQuery: new SpecialQuery('stream')\r\n};\r\n\r\nmodule.exports = {\r\n    SpecialQuery: SpecialQuery,\r\n    cache: cache\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-pg-promise/node_modules/pg-promise/lib/query.js":"'use strict';\r\n\r\nvar $npm = {\r\n    utils: require('./utils'),\r\n    special: require('./special'),\r\n    QueryFile: require('./queryFile'),\r\n    formatting: require('./formatting'),\r\n    result: require('./result'),\r\n    errors: require('./errors'),\r\n    events: require('./events'),\r\n    stream: require('./stream'),\r\n    types: require('./types')\r\n};\r\n\r\nvar QueryResultError = $npm.errors.QueryResultError,\r\n    InternalError = $npm.utils.InternalError,\r\n    ExternalQuery = $npm.types.ExternalQuery,\r\n    PreparedStatement = $npm.types.PreparedStatement,\r\n    ParameterizedQuery = $npm.types.ParameterizedQuery,\r\n    SpecialQuery = $npm.special.SpecialQuery,\r\n    qrec = $npm.errors.queryResultErrorCode;\r\n\r\nvar badMask = $npm.result.one | $npm.result.many; // the combination isn't supported;\r\n\r\n//////////////////////////////\r\n// Generic query method;\r\nfunction $query(ctx, query, values, qrm, config) {\r\n\r\n    var isResult, $p = config.promise;\r\n\r\n    if (qrm instanceof SpecialQuery) {\r\n        if (qrm.isStream) {\r\n            return $npm.stream.call(this, ctx, query, values, config);\r\n        }\r\n        isResult = qrm.isResult;\r\n    }\r\n\r\n    var error, isFunc,\r\n        opt = ctx.options,\r\n        pgFormatting = opt.pgFormatting,\r\n        capSQL = opt.capSQL,\r\n        params = pgFormatting ? values : undefined;\r\n\r\n    if (!query) {\r\n        error = new TypeError('Empty or undefined query.');\r\n    }\r\n\r\n    if (!error && typeof query === 'object') {\r\n        if (query instanceof $npm.QueryFile) {\r\n            query.prepare();\r\n            if (query.error) {\r\n                error = query.error;\r\n                query = query.file;\r\n            } else {\r\n                query = query.query;\r\n            }\r\n        } else {\r\n            if ('funcName' in query) {\r\n                isFunc = true;\r\n                query = query.funcName; // query is a function name;\r\n            } else {\r\n                if (query instanceof ExternalQuery) {\r\n                    pgFormatting = true;\r\n                } else {\r\n                    if ('name' in query) {\r\n                        query = new PreparedStatement(query);\r\n                        pgFormatting = true;\r\n                    } else {\r\n                        if ('text' in query) {\r\n                            query = new ParameterizedQuery(query);\r\n                            pgFormatting = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (query instanceof ExternalQuery && !$npm.utils.isNull(values)) {\r\n                    query.values = values;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!error) {\r\n        if (!pgFormatting && !$npm.utils.isText(query)) {\r\n            error = new TypeError(isFunc ? 'Invalid function name.' : 'Invalid query format.');\r\n        }\r\n        if (query instanceof ExternalQuery) {\r\n            var qp = query.parse();\r\n            if (qp instanceof Error) {\r\n                error = qp;\r\n            } else {\r\n                query = qp;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!error && !isResult) {\r\n        if ($npm.utils.isNull(qrm)) {\r\n            qrm = $npm.result.any; // default query result;\r\n        } else {\r\n            if (qrm !== parseInt(qrm) || (qrm & badMask) === badMask || qrm < 1 || qrm > 6) {\r\n                error = new TypeError('Invalid Query Result Mask specified.');\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!error && (!pgFormatting || isFunc)) {\r\n        try {\r\n            // use 'pg-promise' implementation of values formatting;\r\n            if (isFunc) {\r\n                query = $npm.formatting.formatFunction(query, values, capSQL);\r\n            } else {\r\n                query = $npm.formatting.formatQuery(query, values);\r\n            }\r\n        } catch (e) {\r\n            if (isFunc) {\r\n                var prefix = capSQL ? 'SELECT * FROM' : 'select * from';\r\n                query = prefix + ' ' + query + '(...)';\r\n            }\r\n            error = e instanceof Error ? e : new $npm.utils.InternalError(e);\r\n            params = values;\r\n        }\r\n    }\r\n\r\n    return $p((resolve, reject) => {\r\n\r\n        if (notifyReject()) {\r\n            return;\r\n        }\r\n        error = $npm.events.query(opt, getContext());\r\n        if (notifyReject()) {\r\n            return;\r\n        }\r\n        var start = Date.now();\r\n        try {\r\n            ctx.db.client.query(query, params, (err, result) => {\r\n                var data;\r\n                if (!err) {\r\n                    $npm.utils.addReadProp(result, 'duration', Date.now() - start);\r\n                    $npm.utils.addReadProp(result.rows, 'duration', result.duration, true);\r\n                    if (result.rows.length) {\r\n                        err = $npm.events.receive(opt, result.rows, result, getContext());\r\n                        err = err || error;\r\n                    }\r\n                }\r\n                if (err) {\r\n                    error = err;\r\n                } else {\r\n                    if (isResult) {\r\n                        data = result; // raw object requested (Result type);\r\n                    } else {\r\n                        data = result.rows;\r\n                        var len = data.length;\r\n                        if (len) {\r\n                            if (len > 1 && qrm & $npm.result.one) {\r\n                                // one row was expected, but returned multiple;\r\n                                error = new QueryResultError(qrec.multiple, result, query, params);\r\n                            } else {\r\n                                if (!(qrm & ($npm.result.one | $npm.result.many))) {\r\n                                    // no data should have been returned;\r\n                                    error = new QueryResultError(qrec.notEmpty, result, query, params);\r\n                                } else {\r\n                                    if (!(qrm & $npm.result.many)) {\r\n                                        data = data[0];\r\n                                    }\r\n                                }\r\n                            }\r\n                        } else {\r\n                            // no data returned;\r\n                            if (qrm & $npm.result.none) {\r\n                                if (qrm & $npm.result.one) {\r\n                                    data = null;\r\n                                } else {\r\n                                    data = qrm & $npm.result.many ? data : null;\r\n                                }\r\n                            } else {\r\n                                error = new QueryResultError(qrec.noData, result, query, params);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (!notifyReject()) {\r\n                    resolve(data);\r\n                }\r\n            });\r\n        } catch (e) {\r\n            // this can only happen as a result of an internal failure within node-postgres,\r\n            // like during a sudden loss of communications, which is impossible to reproduce\r\n            // automatically, so removing it from the test coverage:\r\n            // istanbul ignore next\r\n            error = e;\r\n        }\r\n\r\n        function getContext() {\r\n            var client;\r\n            if (ctx.db) {\r\n                client = ctx.db.client;\r\n            } else {\r\n                error = new Error('Loose request outside an expired connection.');\r\n            }\r\n            return {\r\n                client: client,\r\n                dc: ctx.dc,\r\n                query: query,\r\n                params: params,\r\n                ctx: ctx.ctx\r\n            };\r\n        }\r\n\r\n        notifyReject();\r\n\r\n        function notifyReject() {\r\n            var context = getContext();\r\n            if (error) {\r\n                if (error instanceof InternalError) {\r\n                    error = error.error;\r\n                }\r\n                $npm.events.error(opt, error, context);\r\n                reject(error);\r\n                return true;\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\nmodule.exports = config => {\r\n    return function (ctx, query, values, qrm) {\r\n        return $query.call(this, ctx, query, values, qrm, config);\r\n    };\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-pg-promise/node_modules/pg-promise/lib/stream.js":"'use strict';\r\n\r\nvar $npm = {\r\n    events: require('./events'),\r\n    utils: require('./utils')\r\n};\r\n\r\n////////////////////////////////////////////\r\n// Streams query data into any destination,\r\n// with the help of pg-query-stream library.\r\nfunction $stream(ctx, qs, initCB, config) {\r\n\r\n    var $p = config.promise;\r\n\r\n    // istanbul ignore next:\r\n    // we do not provide code coverage for the Native Bindings specifics\r\n    if (ctx.options.pgNative) {\r\n        return $p.reject(new Error('Streaming doesn\\'t work with Native Bindings.'));\r\n    }\r\n    if (!$npm.utils.isObject(qs, ['state', '_reading'])) {\r\n        // stream object wasn't passed in correctly;\r\n        return $p.reject(new TypeError('Invalid or missing stream object.'));\r\n    }\r\n    if (qs._reading || qs.state !== 'initialized') {\r\n        // stream object is in the wrong state;\r\n        return $p.reject(new Error('Invalid stream state.'));\r\n    }\r\n    if (typeof initCB !== 'function') {\r\n        // parameter `initCB` must be passed as the initialization callback;\r\n        return $p.reject(new TypeError('Invalid or missing stream initialization callback.'));\r\n    }\r\n    var error = $npm.events.query(ctx.options, getContext());\r\n    if (error) {\r\n        error = getError(error);\r\n        $npm.events.error(ctx.options, error, getContext());\r\n        return $p.reject(error);\r\n    }\r\n    var stream, fetch, start, nRows = 0;\r\n    try {\r\n        stream = ctx.db.client.query(qs);\r\n        fetch = stream._fetch;\r\n        stream._fetch = (size, func) => {\r\n            fetch.call(stream, size, (err, rows) => {\r\n                if (!err && rows.length) {\r\n                    nRows += rows.length;\r\n                    var context = getContext();\r\n                    if (!error) {\r\n                        error = $npm.events.receive(ctx.options, rows, undefined, context);\r\n                    }\r\n                    if (error) {\r\n                        stream.close();\r\n                    }\r\n                }\r\n                return func(err, rows);\r\n            });\r\n        };\r\n        start = Date.now();\r\n        initCB.call(this, stream); // the stream must be initialized during the call;\r\n    } catch (err) {\r\n        error = err;\r\n    }\r\n    if (error) {\r\n        // error thrown by initCB();\r\n        stream._fetch = fetch;\r\n        error = getError(error);\r\n        $npm.events.error(ctx.options, error, getContext());\r\n        return $p.reject(error);\r\n    }\r\n    return $p((resolve, reject) => {\r\n        stream.once('end', () => {\r\n            stream._fetch = fetch;\r\n            if (error) {\r\n                onError(error);\r\n            } else {\r\n                resolve({\r\n                    processed: nRows, // total number of rows processed;\r\n                    duration: Date.now() - start // duration, in milliseconds;\r\n                });\r\n            }\r\n        });\r\n        stream.once('error', err => {\r\n            stream._fetch = fetch;\r\n            onError(err);\r\n        });\r\n        function onError(e) {\r\n            e = getError(e);\r\n            $npm.events.error(ctx.options, e, getContext());\r\n            reject(e);\r\n        }\r\n    });\r\n\r\n    function getError(e) {\r\n        return e instanceof $npm.utils.InternalError ? e.error : e;\r\n    }\r\n\r\n    function getContext() {\r\n        var client;\r\n        if (ctx.db) {\r\n            client = ctx.db.client;\r\n        } else {\r\n            error = new Error('Loose request outside an expired connection.');\r\n        }\r\n        return {\r\n            client: client,\r\n            dc: ctx.dc,\r\n            query: qs.text,\r\n            params: qs.values,\r\n            ctx: ctx.ctx\r\n        };\r\n    }\r\n\r\n}\r\n\r\nmodule.exports = $stream;\r\n","/home/travis/build/npmtest/node-npmtest-pg-promise/node_modules/pg-promise/lib/task.js":"'use strict';\r\n\r\nvar $npm = {\r\n    spex: require('spex'),\r\n    utils: require('./utils'),\r\n    mode: require('./txMode'),\r\n    events: require('./events'),\r\n    query: require('./query'),\r\n    async: require('./async')\r\n};\r\n\r\n/**\r\n * @interface Task\r\n * @extends Database\r\n * @description\r\n * Extends {@link Database} for an automatic connection session, with methods for executing multiple database queries.\r\n * The type isn't available directly, it can only be created via methods {@link Database.task} and {@link Database.tx}.\r\n *\r\n * When executing more than one request at a time, one should allocate and release the connection only once,\r\n * while executing all the required queries within the same connection session. More importantly, a transaction\r\n * can only work within a single connection.\r\n *\r\n * This is an interface for tasks/transactions to implement a connection session, during which you can\r\n * execute multiple queries against the same connection that's released automatically when the task/transaction is finished.\r\n *\r\n * @see\r\n * {@link Task.ctx ctx},\r\n * {@link Task.batch batch},\r\n * {@link Task.sequence sequence},\r\n * {@link Task.page page}\r\n *\r\n * @example\r\n * db.task(t => {\r\n *       // t = task protocol context;\r\n *       // t.ctx = task config + state context;\r\n *       return t.one(\"select * from users where id=$1\", 123)\r\n *           .then(user => {\r\n *               return t.any(\"select * from events where login=$1\", user.name);\r\n *           });\r\n *   })\r\n * .then(events => {\r\n *       // success;\r\n *   })\r\n * .catch(error => {\r\n *       // error;\r\n *   });\r\n *\r\n */\r\nfunction Task(ctx, tag, isTX, config) {\r\n\r\n    /**\r\n     * @member {object} Task.ctx\r\n     * @description\r\n     * Task/Transaction Context object - contains individual properties for each task/transaction.\r\n     *\r\n     * ```js\r\n     * db.task(t => {\r\n     *    // t.ctx = task context object\r\n     * });\r\n     * ```\r\n     *\r\n     * ```js\r\n     * db.tx(t => {\r\n     *    // t.ctx = transaction context object\r\n     * });\r\n     * ```\r\n     *\r\n     * Properties `context`, `dc`, `isTX`, `tag`, `start` and `isFresh` are set before the callback,\r\n     * while properties `finish`, `success` and `result` are set after the callback has returned.\r\n     *\r\n     * @property {object} context\r\n     * If the operation was invoked with an object context - `task.call(obj,...)` or\r\n     * `tx.call(obj,...)`, this property is set with the context object that was passed in.\r\n     *\r\n     * @property {} dc\r\n     * _Database Context_ that was used when creating the database object. See {@link Database}.\r\n     *\r\n     * @property {boolean} isTX\r\n     * Indicates whether this task represents a transaction.\r\n     *\r\n     * @property {} tag\r\n     * Tag value as it was passed into the task. See methods {@link Database.task task} and {@link Database.tx tx}.\r\n     *\r\n     * @property {date} start\r\n     * Date/Time of when this task or transaction started the execution.\r\n     *\r\n     * @property {boolean} isFresh\r\n     * Indicates when a fresh physical connection is being used.\r\n     *\r\n     * @property {date} finish\r\n     * Once the operation has finished, this property is set to the Data/Time of when it happened.\r\n     *\r\n     * @property {boolean} success\r\n     * Once the operation has finished, this property indicates whether it was successful.\r\n     *\r\n     * @property {} result\r\n     * Once the operation has finished, this property contains the result, depending on property `success`:\r\n     * - data resolved by the operation, if `success` = `true`\r\n     * - error / rejection reason, if `success` = `false`\r\n     *\r\n     * @see event {@link event:query query}\r\n     */\r\n    this.ctx = ctx.ctx = {}; // task context object;\r\n\r\n    $npm.utils.addReadProp(this.ctx, 'isTX', isTX);\r\n\r\n    if ('context' in ctx) {\r\n        $npm.utils.addReadProp(this.ctx, 'context', ctx.context);\r\n    }\r\n\r\n    $npm.utils.addReadProp(this.ctx, 'tag', tag);\r\n    $npm.utils.addReadProp(this.ctx, 'dc', ctx.dc);\r\n\r\n    // generic query method;\r\n    this.query = function (query, values, qrm) {\r\n        if (!ctx.db) {\r\n            throw new Error('Unexpected call outside of ' + (isTX ? 'transaction.' : 'task.'));\r\n        }\r\n        return config.$npm.query.call(this, ctx, query, values, qrm);\r\n    };\r\n\r\n    /**\r\n     * @method Task.batch\r\n     * @description\r\n     * **Alternative Syntax:** `batch(values, {cb})` &#8658; `Promise`\r\n     *\r\n     * Settles a predefined array of mixed values by redirecting to method $[spex.batch].\r\n     *\r\n     * For complete method documentation see $[spex.batch].\r\n     * @param {array} values\r\n     * @param {function} [cb]\r\n     * @returns {external:Promise}\r\n     */\r\n    this.batch = function (values, cb) {\r\n        return config.$npm.spex.batch.call(this, values, cb);\r\n    };\r\n\r\n    /**\r\n     * @method Task.page\r\n     * @description\r\n     * **Alternative Syntax:** `page(source, {dest, limit})` &#8658; `Promise`\r\n     *\r\n     * Resolves a dynamic sequence of arrays/pages with mixed values, by redirecting to method $[spex.page].\r\n     *\r\n     * For complete method documentation see $[spex.page].\r\n     * @param {function} source\r\n     * @param {function} [dest]\r\n     * @param {number} [limit=0]\r\n     * @returns {external:Promise}\r\n     */\r\n    this.page = function (source, dest, limit) {\r\n        return config.$npm.spex.page.call(this, source, dest, limit);\r\n    };\r\n\r\n    /**\r\n     * @method Task.sequence\r\n     * @description\r\n     * **Alternative Syntax:** `sequence(source, {dest, limit, track})` &#8658; `Promise`\r\n     *\r\n     * Resolves a dynamic sequence of mixed values by redirecting to method $[spex.sequence].\r\n     *\r\n     * For complete method documentation see $[spex.sequence].\r\n     * @param {function} source\r\n     * @param {function} [dest]\r\n     * @param {number} [limit=0]\r\n     * @param {boolean} [track=false]\r\n     * @returns {external:Promise}\r\n     */\r\n    this.sequence = function (source, dest, limit, track) {\r\n        return config.$npm.spex.sequence.call(this, source, dest, limit, track);\r\n    };\r\n\r\n}\r\n\r\n//////////////////////////\r\n// Executes a task;\r\nTask.exec = (ctx, obj, isTX, config) => {\r\n\r\n    var $p = config.promise;\r\n\r\n    // callback invocation helper;\r\n    function callback() {\r\n        var result, cb = ctx.cb;\r\n        if (cb.constructor.name === 'GeneratorFunction') {\r\n            cb = config.$npm.async(cb);\r\n        }\r\n        try {\r\n            result = cb.call(obj, obj); // invoking the callback function;\r\n        } catch (err) {\r\n            $npm.events.error(ctx.options, err, {\r\n                client: ctx.db.client,\r\n                dc: ctx.dc,\r\n                ctx: ctx.ctx\r\n            });\r\n            return $p.reject(err); // reject with the error;\r\n        }\r\n        if (result && typeof result.then === 'function') {\r\n            return result; // result is a valid promise object;\r\n        }\r\n        return $p.resolve(result);\r\n    }\r\n\r\n    // updates the task context and notifies the client;\r\n    function update(start, success, result) {\r\n        var c = ctx.ctx;\r\n        if (start) {\r\n            $npm.utils.addReadProp(c, 'start', new Date());\r\n        } else {\r\n            c.finish = new Date();\r\n            c.success = success;\r\n            c.result = result;\r\n            $npm.utils.lock(c, true);\r\n        }\r\n        (isTX ? $npm.events.transact : $npm.events.task)(ctx.options, {\r\n            client: ctx.db.client,\r\n            dc: ctx.dc,\r\n            ctx: c\r\n        });\r\n    }\r\n\r\n    var cbData, cbReason, success,\r\n        spName, // Save-Point Name;\r\n        capSQL = ctx.options.capSQL; // capitalize sql;\r\n\r\n    update(true);\r\n\r\n    if (isTX) {\r\n        // executing a transaction;\r\n        spName = 'level_' + ctx.txLevel;\r\n        return begin()\r\n            .then(() => {\r\n                    return callback()\r\n                        .then(data => {\r\n                            cbData = data; // save callback data;\r\n                            success = true;\r\n                            return commit();\r\n                        }, reason => {\r\n                            cbReason = reason; // save callback failure reason;\r\n                            return rollback();\r\n                        })\r\n                        .then(() => {\r\n                                if (success) {\r\n                                    update(false, true, cbData);\r\n                                    return cbData;\r\n                                }\r\n                                update(false, false, cbReason);\r\n                                return $p.reject(cbReason);\r\n                            },\r\n                            // istanbul ignore next: either `commit` or `rollback` has failed, which is\r\n                            // impossible to replicate in a test environment, so skipping from the test;\r\n                            function (reason) {\r\n                                update(false, false, reason);\r\n                                return $p.reject(reason);\r\n                            });\r\n                },\r\n                // istanbul ignore next: `begin` has failed, which is impossible\r\n                // to replicate in a test environment, so skipping from the test;\r\n                function (reason) {\r\n                    update(false, false, reason);\r\n                    return $p.reject(reason);\r\n                });\r\n    }\r\n\r\n    function begin() {\r\n        if (!ctx.txLevel && ctx.cb.txMode instanceof $npm.mode.TransactionMode) {\r\n            return exec(ctx.cb.txMode.begin(capSQL), 'savepoint');\r\n        }\r\n        return exec('begin', 'savepoint');\r\n    }\r\n\r\n    function commit() {\r\n        return exec('commit', 'release savepoint');\r\n    }\r\n\r\n    function rollback() {\r\n        return exec('rollback', 'rollback to savepoint');\r\n    }\r\n\r\n    function exec(top, nested) {\r\n        if (ctx.txLevel) {\r\n            return obj.none((capSQL ? nested.toUpperCase() : nested) + ' ' + spName);\r\n        }\r\n        return obj.none(capSQL ? top.toUpperCase() : top);\r\n    }\r\n\r\n    // executing a task;\r\n    return callback()\r\n        .then(data => {\r\n            update(false, true, data);\r\n            return data;\r\n        })\r\n        .catch(error => {\r\n            update(false, false, error);\r\n            return $p.reject(error);\r\n        });\r\n\r\n};\r\n\r\nmodule.exports = config => {\r\n    var npm = config.$npm;\r\n\r\n    // istanbul ignore next:\r\n    // we keep 'npm.query' initialization here, even though it is always\r\n    // pre-initialized by the 'database' module, for integrity purpose. \r\n    npm.query = npm.query || $npm.query(config);\r\n\r\n    npm.async = npm.async || $npm.async(config);\r\n    npm.spex = npm.spex || $npm.spex(config.promiseLib);\r\n    return Task;\r\n};\r\n"}